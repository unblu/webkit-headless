diff -Nbaur qt/qtbase/src/corelib/global/qnamespace.h qt.new/qtbase/src/corelib/global/qnamespace.h
--- qt/qtbase/src/corelib/global/qnamespace.h	2015-12-17 16:23:53.000000000 +0100
+++ qt.new/qtbase/src/corelib/global/qnamespace.h	2015-12-17 16:26:56.000000000 +0100
@@ -496,6 +496,8 @@
         AA_UseSoftwareOpenGL = 17,
         AA_ShareOpenGLContexts = 18,
         AA_SetPalette = 19,
+        AA_MacUseOffscreenScreen = 20,
+        AA_UseSimpleDnD = 21,
 
         // Add new attributes before this line
         AA_AttributeCount
diff -Nbaur qt/qtbase/src/corelib/tools/qlocale.cpp qt.new/qtbase/src/corelib/tools/qlocale.cpp
--- qt/qtbase/src/corelib/tools/qlocale.cpp	2015-12-17 16:23:53.000000000 +0100
+++ qt.new/qtbase/src/corelib/tools/qlocale.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -2024,7 +2024,7 @@
 
 QLocale QLocale::system()
 {
-    return QLocale(*QLocalePrivate::create(systemData()));
+    return QLocale(*QLocalePrivate::create(defaultData()));
 }
 
 
diff -Nbaur qt/qtbase/src/gui/kernel/qsimpledrag.cpp qt.new/qtbase/src/gui/kernel/qsimpledrag.cpp
--- qt/qtbase/src/gui/kernel/qsimpledrag.cpp	2015-12-17 16:23:53.000000000 +0100
+++ qt.new/qtbase/src/gui/kernel/qsimpledrag.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -62,7 +62,7 @@
 
 static QWindow* topLevelAt(const QPoint &pos)
 {
-    QWindowList list = QGuiApplication::topLevelWindows();
+    QWindowList list = QGuiApplication::allWindows();	// topLevelWindows();
     for (int i = list.count()-1; i >= 0; --i) {
         QWindow *w = list.at(i);
         if (w->isVisible() && w->geometry().contains(pos) && !qobject_cast<QShapedPixmapWindow*>(w))
@@ -267,15 +267,15 @@
     QCursor *cursor = QGuiApplication::overrideCursor();
     QPixmap pixmap = m_drag->dragCursor(action);
     if (!cursor) {
-        QGuiApplication::changeOverrideCursor((pixmap.isNull()) ? QCursor(cursorShape) : QCursor(pixmap));
+        updateCursor((pixmap.isNull()) ? QCursor(cursorShape) : QCursor(pixmap));
     } else {
         if (!pixmap.isNull()) {
             if ((cursor->pixmap().cacheKey() != pixmap.cacheKey())) {
-                QGuiApplication::changeOverrideCursor(QCursor(pixmap));
+                updateCursor(QCursor(pixmap));
             }
         } else {
             if (cursorShape != cursor->shape()) {
-                QGuiApplication::changeOverrideCursor(QCursor(cursorShape));
+                updateCursor(QCursor(cursorShape));
             }
         }
     }
@@ -283,6 +283,11 @@
     updateAction(action);
 }
 
+void QBasicDrag::updateCursor(const QCursor& cursor)
+{
+	QGuiApplication::changeOverrideCursor(cursor);
+}
+
 /*!
     \class QSimpleDrag
     \brief QSimpleDrag implements QBasicDrag for Drag and Drop operations within the Qt Application itself.
@@ -362,6 +367,27 @@
     }
 }
 
+void QSimpleDrag::restoreCursor()
+{
+	if(m_restoreCursor) {
+		QBasicDrag::restoreCursor();
+#ifndef QT_NO_CURSOR
+		QCursor *cur = QGuiApplication::overrideCursor();
+
+		if(m_current_window)
+			m_current_window->setCursor(cur ? *cur : QCursor());
+#endif
+	}
+}
+
+void QSimpleDrag::updateCursor(const QCursor& cursor)
+{
+	QBasicDrag::updateCursor(cursor);
+
+	if(m_current_window)
+		m_current_window->setCursor(cursor);
+}
+
 #endif // QT_NO_DRAGANDDROP
 
 QT_END_NAMESPACE
diff -Nbaur qt/qtbase/src/gui/kernel/qsimpledrag_p.h qt.new/qtbase/src/gui/kernel/qsimpledrag_p.h
--- qt/qtbase/src/gui/kernel/qsimpledrag_p.h	2015-12-17 16:23:53.000000000 +0100
+++ qt.new/qtbase/src/gui/kernel/qsimpledrag_p.h	2015-12-17 16:26:56.000000000 +0100
@@ -77,6 +77,9 @@
     virtual void drop(const QMouseEvent *me);
     virtual void endDrag();
 
+    virtual void restoreCursor();
+    virtual void updateCursor(const QCursor& cursor);
+
     QShapedPixmapWindow *shapedPixmapWindow() const { return m_drag_icon_window; }
     void updateCursor(Qt::DropAction action);
 
@@ -88,13 +91,13 @@
 
     QDrag *drag() const { return m_drag; }
 
+    bool m_restoreCursor;
+
 private:
     void enableEventFilter();
     void disableEventFilter();
-    void restoreCursor();
     void exitDndEventLoop();
 
-    bool m_restoreCursor;
     QEventLoop *m_eventLoop;
     Qt::DropAction m_executed_drop_action;
     bool m_can_drop;
@@ -114,6 +117,10 @@
     virtual void move(const QMouseEvent *me) Q_DECL_OVERRIDE;
     virtual void drop(const QMouseEvent *me) Q_DECL_OVERRIDE;
 
+    using QBasicDrag::updateCursor;
+    virtual void restoreCursor();
+    virtual void updateCursor(const QCursor& cursor);
+
 private:
     QWindow *m_current_window;
 };
diff -Nbaur qt/qtbase/src/platformsupport/themes/genericunix/qgenericunixthemes.cpp qt.new/qtbase/src/platformsupport/themes/genericunix/qgenericunixthemes.cpp
--- qt/qtbase/src/platformsupport/themes/genericunix/qgenericunixthemes.cpp	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/platformsupport/themes/genericunix/qgenericunixthemes.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -683,7 +683,7 @@
 #endif
     if (name == QLatin1String(QGnomeTheme::name))
         return new QGnomeTheme;
-    return new QGenericUnixTheme;
+    return new QPlatformTheme;
 }
 
 QStringList QGenericUnixTheme::themeNames()
diff -Nbaur qt/qtbase/src/plugins/imageformats/cur/cur.json qt.new/qtbase/src/plugins/imageformats/cur/cur.json
--- qt/qtbase/src/plugins/imageformats/cur/cur.json	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/imageformats/cur/cur.json	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,4 @@
+{
+    "Keys": [ "cur" ],
+    "MimeTypes": [ "image/vnd.microsoft.icon" ]
+}
diff -Nbaur qt/qtbase/src/plugins/imageformats/cur/cur.pro qt.new/qtbase/src/plugins/imageformats/cur/cur.pro
--- qt/qtbase/src/plugins/imageformats/cur/cur.pro	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/imageformats/cur/cur.pro	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,12 @@
+TARGET  = qcur
+
+PLUGIN_TYPE = imageformats
+PLUGIN_CLASS_NAME = QCURPlugin
+load(qt_plugin)
+
+QTDIR_build:REQUIRES = "!contains(QT_CONFIG, no-cur)"
+
+HEADERS += qcurhandler.h main.h
+SOURCES += main.cpp \
+           qcurhandler.cpp
+OTHER_FILES += cur.json
diff -Nbaur qt/qtbase/src/plugins/imageformats/cur/main.cpp qt.new/qtbase/src/plugins/imageformats/cur/main.cpp
--- qt/qtbase/src/plugins/imageformats/cur/main.cpp	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/imageformats/cur/main.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * main.cpp
+ *
+ *  Created on: Jan 11, 2013
+ *      Author: mike
+ */
+
+#include "main.h"
+
+#ifndef QT_NO_IMAGEFORMATPLUGIN
+
+QT_BEGIN_NAMESPACE
+
+QImageIOPlugin::Capabilities QCURPlugin::capabilities(QIODevice *device, const QByteArray &format) const
+{
+    if (format == "cur")
+        return Capabilities(CanRead | CanWrite);
+    if (!format.isEmpty())
+        return 0;
+    if (!device->isOpen())
+        return 0;
+
+    Capabilities cap;
+    if (device->isReadable() && QtCurHandler::canRead(device))
+        cap |= CanRead;
+    if (device->isWritable())
+        cap |= CanWrite;
+    return cap;
+}
+
+QImageIOHandler *QCURPlugin::create(QIODevice *device, const QByteArray &format) const
+{
+    QImageIOHandler *handler = new QtCurHandler(device);
+
+    handler->setFormat(format);
+    return handler;
+}
+
+QT_END_NAMESPACE
+
+#endif /* QT_NO_IMAGEFORMATPLUGIN */
+
+
+
diff -Nbaur qt/qtbase/src/plugins/imageformats/cur/main.h qt.new/qtbase/src/plugins/imageformats/cur/main.h
--- qt/qtbase/src/plugins/imageformats/cur/main.h	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/imageformats/cur/main.h	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+ * main.cpp
+ *
+ *  Created on: Aug 14, 2014
+ *      Author: mike
+ */
+
+#include <qimageiohandler.h>
+#include <qdebug.h>
+
+#ifndef QT_NO_IMAGEFORMATPLUGIN
+
+#ifdef QT_NO_IMAGEFORMAT_CUR
+#undef QT_NO_IMAGEFORMAT_CUR
+#endif
+#include "qcurhandler.h"
+
+QT_BEGIN_NAMESPACE
+
+class QCURPlugin : public QImageIOPlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QImageIOHandlerFactoryInterface" FILE "cur.json")
+public:
+    Capabilities capabilities(QIODevice *device, const QByteArray &format) const;
+    QImageIOHandler *create(QIODevice *device, const QByteArray &format = QByteArray()) const;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff -Nbaur qt/qtbase/src/plugins/imageformats/cur/qcurhandler.cpp qt.new/qtbase/src/plugins/imageformats/cur/qcurhandler.cpp
--- qt/qtbase/src/plugins/imageformats/cur/qcurhandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/imageformats/cur/qcurhandler.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,850 @@
+/*
+ * qcurhandler.cpp
+ *
+ *  Created on: Jan 11, 2013
+ *      Author: mike
+ */
+
+#include "qcurhandler.h"
+#include <QtCore/qendian.h>
+#include <QtGui/QImage>
+#include <QtCore/QFile>
+#include <QtCore/QBuffer>
+#include <qvariant.h>
+
+QT_BEGIN_NAMESPACE
+
+// These next two structs represent how the icon information is stored
+// in an ICO/CUR file.
+typedef struct
+{
+    quint8  bWidth;               // Width of the image
+    quint8  bHeight;              // Height of the image (times 2)
+    quint8  bColorCount;          // Number of colors in image (0 if >=8bpp) [ not ture ]
+    quint8  bReserved;            // Reserved
+    quint16 wHotspotX;            // hotspot x
+    quint16 wHotspotY;            // hotspot y
+    quint32 dwBytesInRes;         // how many bytes in this resource?
+    quint32 dwImageOffset;        // where in the file is this image
+} ICONDIRENTRY, *LPICONDIRENTRY;
+#define ICONDIRENTRY_SIZE 16
+
+typedef struct
+{
+    quint16 idReserved;   // Reserved
+    quint16 idType;       // resource type (1 for icons, 2 for cur)
+    quint16 idCount;      // how many images?
+    ICONDIRENTRY    idEntries[1]; // the entries for each image
+} ICONDIR, *LPICONDIR;
+#define ICONDIR_SIZE    6       // Exclude the idEntries field
+
+typedef struct {                    // BMP information header
+    quint32 biSize;                // size of this struct
+    quint32 biWidth;               // pixmap width
+    quint32 biHeight;              // pixmap height     (specifies the combined height of the XOR and AND masks)
+    quint16 biPlanes;              // should be 1
+    quint16 biBitCount;            // number of bits per pixel
+    quint32 biCompression;         // compression method
+    quint32 biSizeImage;           // size of image
+    quint32 biXPelsPerMeter;       // horizontal resolution
+    quint32 biYPelsPerMeter;       // vertical resolution
+    quint32 biClrUsed;             // number of colors used
+    quint32 biClrImportant;        // number of important colors
+} BMP_INFOHDR ,*LPBMP_INFOHDR;
+#define BMP_INFOHDR_SIZE 40
+
+class CURReader
+{
+public:
+	CURReader(QIODevice * iodevice);
+    int count();
+    QImage iconAt(int index);
+    static bool canRead(QIODevice *iodev);
+
+    static QList<QImage> read(QIODevice * device);
+
+    static bool write(QIODevice * device, const QList<QImage> & images);
+
+private:
+    bool readHeader();
+    bool readIconEntry(int index, ICONDIRENTRY * iconEntry);
+
+    bool readBMPHeader(quint32 imageOffset, BMP_INFOHDR * header);
+    void findColorInfo(QImage & image);
+    void readColorTable(QImage & image);
+
+    void readBMP(QImage & image);
+    void read1BitBMP(QImage & image);
+    void read4BitBMP(QImage & image);
+    void read8BitBMP(QImage & image);
+    void read16_24_32BMP(QImage & image);
+
+    struct IcoAttrib
+    {
+        int nbits;
+        int ncolors;
+        int h;
+        int w;
+        int depth;
+    } icoAttrib;
+
+    QIODevice * iod;
+    qint64 startpos;
+    bool headerRead;
+    ICONDIR iconDir;
+
+};
+
+// Data readers and writers that takes care of alignment and endian stuff.
+static bool readIconDirEntry(QIODevice *iodev, ICONDIRENTRY *iconDirEntry)
+{
+    if (iodev) {
+        uchar tmp[ICONDIRENTRY_SIZE];
+        if (iodev->read((char*)tmp, ICONDIRENTRY_SIZE) == ICONDIRENTRY_SIZE) {
+            iconDirEntry->bWidth = tmp[0];
+            iconDirEntry->bHeight = tmp[1];
+            iconDirEntry->bColorCount = tmp[2];
+            iconDirEntry->bReserved = tmp[3];
+
+            iconDirEntry->wHotspotX = qFromLittleEndian<quint16>(&tmp[4]);
+            iconDirEntry->wHotspotY = qFromLittleEndian<quint16>(&tmp[6]);
+            iconDirEntry->dwBytesInRes = qFromLittleEndian<quint32>(&tmp[8]);
+            iconDirEntry->dwImageOffset = qFromLittleEndian<quint32>(&tmp[12]);
+            return true;
+        }
+    }
+    return false;
+}
+
+static bool writeIconDirEntry(QIODevice *iodev, const ICONDIRENTRY &iconEntry)
+{
+    if (iodev) {
+        uchar tmp[ICONDIRENTRY_SIZE];
+        tmp[0] = iconEntry.bWidth;
+        tmp[1] = iconEntry.bHeight;
+        tmp[2] = iconEntry.bColorCount;
+        tmp[3] = iconEntry.bReserved;
+        qToLittleEndian<quint16>(iconEntry.wHotspotX, &tmp[4]);
+        qToLittleEndian<quint16>(iconEntry.wHotspotY, &tmp[6]);
+        qToLittleEndian<quint32>(iconEntry.dwBytesInRes, &tmp[8]);
+        qToLittleEndian<quint32>(iconEntry.dwImageOffset, &tmp[12]);
+        return (iodev->write((char*)tmp,  ICONDIRENTRY_SIZE) == ICONDIRENTRY_SIZE) ? true : false;
+    }
+
+    return false;
+}
+
+static bool readIconDir(QIODevice *iodev, ICONDIR *iconDir)
+{
+    if (iodev) {
+        uchar tmp[ICONDIR_SIZE];
+        if (iodev->read((char*)tmp, ICONDIR_SIZE) == ICONDIR_SIZE) {
+            iconDir->idReserved = qFromLittleEndian<quint16>(&tmp[0]);
+            iconDir->idType = qFromLittleEndian<quint16>(&tmp[2]);
+            iconDir->idCount = qFromLittleEndian<quint16>(&tmp[4]);
+            return true;
+        }
+    }
+    return false;
+}
+
+static bool writeIconDir(QIODevice *iodev, const ICONDIR &iconDir)
+{
+    if (iodev) {
+        uchar tmp[6];
+        qToLittleEndian(iconDir.idReserved, tmp);
+        qToLittleEndian(iconDir.idType, &tmp[2]);
+        qToLittleEndian(iconDir.idCount, &tmp[4]);
+        return (iodev->write((char*)tmp,  6) == 6) ? true : false;
+    }
+    return false;
+}
+
+static bool readBMPInfoHeader(QIODevice *iodev, BMP_INFOHDR *pHeader)
+{
+    if (iodev) {
+        uchar header[BMP_INFOHDR_SIZE];
+        if (iodev->read((char*)header, BMP_INFOHDR_SIZE) == BMP_INFOHDR_SIZE) {
+            pHeader->biSize = qFromLittleEndian<quint32>(&header[0]);
+            pHeader->biWidth = qFromLittleEndian<quint32>(&header[4]);
+            pHeader->biHeight = qFromLittleEndian<quint32>(&header[8]);
+            pHeader->biPlanes = qFromLittleEndian<quint16>(&header[12]);
+            pHeader->biBitCount = qFromLittleEndian<quint16>(&header[14]);
+            pHeader->biCompression = qFromLittleEndian<quint32>(&header[16]);
+            pHeader->biSizeImage = qFromLittleEndian<quint32>(&header[20]);
+            pHeader->biXPelsPerMeter = qFromLittleEndian<quint32>(&header[24]);
+            pHeader->biYPelsPerMeter = qFromLittleEndian<quint32>(&header[28]);
+            pHeader->biClrUsed = qFromLittleEndian<quint32>(&header[32]);
+            pHeader->biClrImportant = qFromLittleEndian<quint32>(&header[36]);
+            return true;
+        }
+    }
+    return false;
+}
+
+static bool writeBMPInfoHeader(QIODevice *iodev, const BMP_INFOHDR &header)
+{
+    if (iodev) {
+        uchar tmp[BMP_INFOHDR_SIZE];
+        qToLittleEndian<quint32>(header.biSize, &tmp[0]);
+        qToLittleEndian<quint32>(header.biWidth, &tmp[4]);
+        qToLittleEndian<quint32>(header.biHeight, &tmp[8]);
+        qToLittleEndian<quint16>(header.biPlanes, &tmp[12]);
+        qToLittleEndian<quint16>(header.biBitCount, &tmp[14]);
+        qToLittleEndian<quint32>(header.biCompression, &tmp[16]);
+        qToLittleEndian<quint32>(header.biSizeImage, &tmp[20]);
+        qToLittleEndian<quint32>(header.biXPelsPerMeter, &tmp[24]);
+        qToLittleEndian<quint32>(header.biYPelsPerMeter, &tmp[28]);
+        qToLittleEndian<quint32>(header.biClrUsed, &tmp[32]);
+        qToLittleEndian<quint32>(header.biClrImportant, &tmp[36]);
+
+        return (iodev->write((char*)tmp, BMP_INFOHDR_SIZE) == BMP_INFOHDR_SIZE) ? true : false;
+    }
+    return false;
+}
+
+CURReader::CURReader(QIODevice * iodevice)
+: iod(iodevice)
+, startpos(0)
+, headerRead(false)
+{
+}
+
+
+int CURReader::count()
+{
+    if (readHeader())
+        return iconDir.idCount;
+    return 0;
+}
+
+bool CURReader::canRead(QIODevice *iodev)
+{
+    bool isProbablyCUR = false;
+    if (iodev) {
+        qint64 oldPos = iodev->pos();
+
+        ICONDIR ikonDir;
+        if (readIconDir(iodev, &ikonDir)) {
+            qint64 readBytes = ICONDIR_SIZE;
+            if (readIconDirEntry(iodev, &ikonDir.idEntries[0])) {
+                readBytes += ICONDIRENTRY_SIZE;
+                // ICO format does not have a magic identifier, so we read 6 different values, which will hopefully be enough to identify the file.
+                if (   ikonDir.idReserved == 0
+                    && ikonDir.idType == 2
+                    && ikonDir.idEntries[0].bReserved == 0
+                    && ikonDir.idEntries[0].dwBytesInRes >= 40  // Must be over 40, since sizeof (infoheader) == 40
+                    ) {
+                	isProbablyCUR = true;
+                }
+
+                if (iodev->isSequential()) {
+                    // Our structs might be padded due to alignment, so we need to fetch each member before we ungetChar() !
+                    quint32 tmp = ikonDir.idEntries[0].dwImageOffset;
+                    iodev->ungetChar((tmp >> 24) & 0xff);
+                    iodev->ungetChar((tmp >> 16) & 0xff);
+                    iodev->ungetChar((tmp >>  8) & 0xff);
+                    iodev->ungetChar(tmp & 0xff);
+
+                    tmp = ikonDir.idEntries[0].dwBytesInRes;
+                    iodev->ungetChar((tmp >> 24) & 0xff);
+                    iodev->ungetChar((tmp >> 16) & 0xff);
+                    iodev->ungetChar((tmp >>  8) & 0xff);
+                    iodev->ungetChar(tmp & 0xff);
+
+                    tmp = ikonDir.idEntries[0].wHotspotX;
+                    iodev->ungetChar((tmp >>  8) & 0xff);
+                    iodev->ungetChar(tmp & 0xff);
+
+                    tmp = ikonDir.idEntries[0].wHotspotY;
+                    iodev->ungetChar((tmp >>  8) & 0xff);
+                    iodev->ungetChar(tmp & 0xff);
+
+                    iodev->ungetChar(ikonDir.idEntries[0].bReserved);
+                    iodev->ungetChar(ikonDir.idEntries[0].bColorCount);
+                    iodev->ungetChar(ikonDir.idEntries[0].bHeight);
+                    iodev->ungetChar(ikonDir.idEntries[0].bWidth);
+                }
+            }
+
+            if (iodev->isSequential()) {
+                // Our structs might be padded due to alignment, so we need to fetch each member before we ungetChar() !
+                quint32 tmp = ikonDir.idCount;
+                iodev->ungetChar((tmp >>  8) & 0xff);
+                iodev->ungetChar(tmp & 0xff);
+
+                tmp = ikonDir.idType;
+                iodev->ungetChar((tmp >>  8) & 0xff);
+                iodev->ungetChar(tmp & 0xff);
+
+                tmp = ikonDir.idReserved;
+                iodev->ungetChar((tmp >>  8) & 0xff);
+                iodev->ungetChar(tmp & 0xff);
+            }
+        }
+        if (!iodev->isSequential()) iodev->seek(oldPos);
+    }
+
+    return isProbablyCUR;
+}
+
+bool CURReader::readHeader()
+{
+    if (iod && !headerRead) {
+        startpos = iod->pos();
+        if (readIconDir(iod, &iconDir)) {
+            if (iconDir.idReserved == 0 || iconDir.idType == 1)
+            headerRead = true;
+        }
+    }
+
+    return headerRead;
+}
+
+bool CURReader::readIconEntry(int index, ICONDIRENTRY *iconEntry)
+{
+    if (iod) {
+        if (iod->seek(startpos + ICONDIR_SIZE + (index * ICONDIRENTRY_SIZE))) {
+            return readIconDirEntry(iod, iconEntry);
+        }
+    }
+    return false;
+}
+
+
+
+bool CURReader::readBMPHeader(quint32 imageOffset, BMP_INFOHDR * header)
+{
+    if (iod) {
+        if (iod->seek(startpos + imageOffset)) {
+            if (readBMPInfoHeader(iod, header)) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+void CURReader::findColorInfo(QImage & image)
+{
+    if (icoAttrib.ncolors > 0) {                // set color table
+        readColorTable(image);
+    } else if (icoAttrib.nbits == 16) { // don't support RGB values for 15/16 bpp
+        image = QImage();
+    }
+}
+
+void CURReader::readColorTable(QImage & image)
+{
+    if (iod) {
+        image.setColorCount(icoAttrib.ncolors);
+        uchar rgb[4];
+        for (int i=0; i<icoAttrib.ncolors; i++) {
+            if (iod->read((char*)rgb, 4) != 4) {
+            image = QImage();
+            break;
+            }
+            image.setColor(i, qRgb(rgb[2],rgb[1],rgb[0]));
+        }
+    } else {
+        image = QImage();
+    }
+}
+
+void CURReader::readBMP(QImage & image)
+{
+    if (icoAttrib.nbits == 1) {                // 1 bit BMP image
+        read1BitBMP(image);
+    } else if (icoAttrib.nbits == 4) {            // 4 bit BMP image
+        read4BitBMP(image);
+    } else if (icoAttrib.nbits == 8) {
+        read8BitBMP(image);
+    } else if (icoAttrib.nbits == 16 || icoAttrib.nbits == 24 || icoAttrib.nbits == 32 ) { // 16,24,32 bit BMP image
+        read16_24_32BMP(image);
+    }
+}
+
+
+/**
+ * NOTE: A 1 bit BMP is only flipped vertically, and not horizontally like all other color depths!
+ * (This is the same with the bitmask)
+ *
+ */
+void CURReader::read1BitBMP(QImage & image)
+{
+    if (iod) {
+
+        int h = image.height();
+        int bpl = image.bytesPerLine();
+
+        while (--h >= 0) {
+            if (iod->read((char*)image.scanLine(h),bpl) != bpl) {
+                image = QImage();
+                break;
+            }
+        }
+    } else {
+        image = QImage();
+    }
+}
+
+void CURReader::read4BitBMP(QImage & image)
+{
+    if (iod) {
+
+        int h = icoAttrib.h;
+        int buflen = ((icoAttrib.w+7)/8)*4;
+        uchar *buf = new uchar[buflen];
+        Q_CHECK_PTR(buf);
+
+        while (--h >= 0) {
+            if (iod->read((char*)buf,buflen) != buflen) {
+                image = QImage();
+                break;
+            }
+            register uchar *p = image.scanLine(h);
+            uchar *b = buf;
+            for (int i=0; i<icoAttrib.w/2; i++) {   // convert nibbles to bytes
+                *p++ = *b >> 4;
+                *p++ = *b++ & 0x0f;
+            }
+            if (icoAttrib.w & 1)                    // the last nibble
+                *p = *b >> 4;
+        }
+
+        delete [] buf;
+
+    } else {
+        image = QImage();
+    }
+}
+
+void CURReader::read8BitBMP(QImage & image)
+{
+    if (iod) {
+
+        int h = icoAttrib.h;
+        int bpl = image.bytesPerLine();
+
+        while (--h >= 0) {
+            if (iod->read((char *)image.scanLine(h), bpl) != bpl) {
+                image = QImage();
+                break;
+            }
+        }
+    } else {
+        image = QImage();
+    }
+}
+
+void CURReader::read16_24_32BMP(QImage & image)
+{
+    if (iod) {
+        int h = icoAttrib.h;
+        register QRgb *p;
+        QRgb  *end;
+        uchar *buf = new uchar[image.bytesPerLine()];
+        int    bpl = ((icoAttrib.w*icoAttrib.nbits+31)/32)*4;
+        uchar *b;
+
+        while (--h >= 0) {
+            p = (QRgb *)image.scanLine(h);
+            end = p + icoAttrib.w;
+            if (iod->read((char *)buf, bpl) != bpl) {
+                image = QImage();
+                break;
+            }
+            b = buf;
+            while (p < end) {
+                if (icoAttrib.nbits == 24)
+                    *p++ = qRgb(*(b+2), *(b+1), *b);
+                else if (icoAttrib.nbits == 32)
+                    *p++ = qRgba(*(b+2), *(b+1), *b, *(b+3));
+                b += icoAttrib.nbits/8;
+            }
+        }
+
+        delete[] buf;
+
+    } else {
+        image = QImage();
+    }
+}
+
+QImage CURReader::iconAt(int index)
+{
+    QImage img;
+
+    if (count() > index) { // forces header to be read
+
+        ICONDIRENTRY iconEntry;
+        if (readIconEntry(index, &iconEntry)) {
+
+            static const uchar pngMagicData[] = { 137, 80, 78, 71, 13, 10, 26, 10 };
+
+            iod->seek(iconEntry.dwImageOffset);
+
+            const QByteArray pngMagic = QByteArray::fromRawData((char*)pngMagicData, sizeof(pngMagicData));
+            const bool isPngImage = (iod->read(pngMagic.size()) == pngMagic);
+
+            if (isPngImage) {
+                iod->seek(iconEntry.dwImageOffset);
+                return QImage::fromData(iod->read(iconEntry.dwBytesInRes), "png");
+            }
+
+            BMP_INFOHDR header;
+            if (readBMPHeader(iconEntry.dwImageOffset, &header)) {
+                icoAttrib.nbits = header.biBitCount ? header.biBitCount : 32;
+
+                switch (icoAttrib.nbits) {
+                case 32:
+                case 24:
+                case 16:
+                    icoAttrib.depth = 32;
+                    break;
+                case 8:
+                case 4:
+                    icoAttrib.depth = 8;
+                    break;
+                default:
+                    icoAttrib.depth = 1;
+                }
+                if (icoAttrib.depth == 32)                // there's no colormap
+                    icoAttrib.ncolors = 0;
+                else                    // # colors used
+                    icoAttrib.ncolors = header.biClrUsed ? header.biClrUsed : 1 << icoAttrib.nbits;
+                if (icoAttrib.ncolors > 256) //color table can't be more than 256
+                    return img;
+                icoAttrib.w = iconEntry.bWidth;
+                if (icoAttrib.w == 0)
+                    icoAttrib.w = header.biWidth;
+                icoAttrib.h = iconEntry.bHeight;
+                if (icoAttrib.h == 0)
+                    icoAttrib.h = header.biHeight/2;
+
+                QImage::Format format = QImage::Format_ARGB32;
+                if (icoAttrib.nbits == 24)
+                    format = QImage::Format_RGB32;
+                else if (icoAttrib.ncolors == 2)
+                    format = QImage::Format_Mono;
+                else if (icoAttrib.ncolors > 0)
+                    format = QImage::Format_Indexed8;
+
+                QImage image(icoAttrib.w, icoAttrib.h, format);
+                if (!image.isNull()) {
+                    findColorInfo(image);
+                    if (!image.isNull()) {
+                        readBMP(image);
+                        if (!image.isNull()) {
+                            QImage mask(image.width(), image.height(), QImage::Format_Mono);
+                            if (!mask.isNull()) {
+                                mask.setColorCount(2);
+                                mask.setColor(0, qRgba(255,255,255,0xff));
+                                mask.setColor(1, qRgba(0  ,0  ,0  ,0xff));
+                                read1BitBMP(mask);
+                                if (!mask.isNull()) {
+                                    img = QImage(image.width(), image.height(), QImage::Format_ARGB32 );
+                                    img = image;
+                                    img.setAlphaChannel(mask);
+                                    // (Luckily, it seems that setAlphaChannel() does not ruin the alpha values
+                                    // of partially transparent pixels in those icons that have that)
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return img;
+}
+
+/*!
+    Reads all the icons from the given \a device, and returns them as
+    a list of QImage objects.
+
+    Each image has an alpha channel that represents the mask from the
+    corresponding icon.
+
+    \sa write()
+*/
+QList<QImage> CURReader::read(QIODevice * device)
+{
+    QList<QImage> images;
+
+    CURReader reader(device);
+    for (int i = 0; i < reader.count(); i++)
+        images += reader.iconAt(i);
+
+    return images;
+}
+
+/*!
+    Writes all the QImages in the \a images list to the given \a
+    device. Returns true if the images are written successfully;
+    otherwise returns false.
+
+    The first image in the list is stored as the first icon in the
+    device, and is therefore used as the default icon by applications.
+    The alpha channel of each image is converted to a mask for each
+    corresponding icon.
+
+    \sa read()
+*/
+bool CURReader::write(QIODevice * device, const QList<QImage> & images)
+{
+    bool retValue = false;
+
+    if (images.count()) {
+
+        qint64 origOffset = device->pos();
+
+        ICONDIR id;
+        id.idReserved = 0;
+        id.idType = 2;
+        id.idCount = images.count();
+
+        ICONDIRENTRY * entries = new ICONDIRENTRY[id.idCount];
+        BMP_INFOHDR * bmpHeaders = new BMP_INFOHDR[id.idCount];
+        QByteArray * imageData = new QByteArray[id.idCount];
+
+        for (int i=0; i<id.idCount; i++) {
+
+            QImage image = images[i];
+            // Scale down the image if it is larger than 128 pixels in either width or height
+            if (image.width() > 128 || image.height() > 128)
+            {
+                image = image.scaled(128, 128, Qt::KeepAspectRatio, Qt::SmoothTransformation);
+            }
+            QImage maskImage(image.width(), image.height(), QImage::Format_Mono);
+            image = image.convertToFormat(QImage::Format_ARGB32);
+
+            if (image.hasAlphaChannel()) {
+                maskImage = image.createAlphaMask();
+            } else {
+                maskImage.fill(0xff);
+            }
+            maskImage = maskImage.convertToFormat(QImage::Format_Mono);
+
+            int    nbits = 32;
+            int    bpl_bmp = ((image.width()*nbits+31)/32)*4;
+
+            entries[i].bColorCount = 0;
+            entries[i].bReserved = 0;
+            entries[i].wHotspotX = 0;
+            entries[i].wHotspotY = 0;
+            entries[i].bHeight = image.height();
+            entries[i].bWidth = image.width();
+            entries[i].dwBytesInRes = BMP_INFOHDR_SIZE + (bpl_bmp * image.height()) + (maskImage.bytesPerLine() * maskImage.height());
+            if (i == 0)
+                entries[i].dwImageOffset = origOffset + ICONDIR_SIZE + (id.idCount * ICONDIRENTRY_SIZE);
+            else
+                entries[i].dwImageOffset = entries[i-1].dwImageOffset + entries[i-1].dwBytesInRes;
+
+            bmpHeaders[i].biBitCount = nbits;
+            bmpHeaders[i].biClrImportant = 0;
+            bmpHeaders[i].biClrUsed = entries[i].bColorCount;
+            bmpHeaders[i].biCompression = 0;
+            bmpHeaders[i].biHeight = entries[i].bHeight * 2; // 2 is for the mask
+            bmpHeaders[i].biPlanes = 1;
+            bmpHeaders[i].biSize = BMP_INFOHDR_SIZE;
+            bmpHeaders[i].biSizeImage = entries[i].dwBytesInRes - BMP_INFOHDR_SIZE;
+            bmpHeaders[i].biWidth = entries[i].bWidth;
+            bmpHeaders[i].biXPelsPerMeter = 0;
+            bmpHeaders[i].biYPelsPerMeter = 0;
+
+            QBuffer buffer(&imageData[i]);
+            buffer.open(QIODevice::WriteOnly);
+
+            uchar *buf = new uchar[bpl_bmp];
+            uchar *b;
+            memset( buf, 0, bpl_bmp );
+            int y;
+            for (y = image.height() - 1; y >= 0; y--) {    // write the image bits
+                // 32 bits
+                QRgb *p   = (QRgb *)image.scanLine(y);
+                QRgb *end = p + image.width();
+                b = buf;
+                int x = 0;
+                while (p < end) {
+                    *b++ = qBlue(*p);
+                    *b++ = qGreen(*p);
+                    *b++ = qRed(*p);
+                    *b++ = qAlpha(*p);
+                    if (qAlpha(*p) > 0)   // Even mostly transparent pixels must not be masked away
+                        maskImage.setPixel(x, y, Qt::color1);  // (i.e. createAlphaMask() takes away too much)
+                    p++;
+                    x++;
+                }
+                buffer.write((char*)buf, bpl_bmp);
+            }
+            delete[] buf;
+
+            maskImage.invertPixels();   // seems as though it needs this
+            // NOTE! !! The mask is only flipped vertically - not horizontally !!
+            for (y = maskImage.height() - 1; y >= 0; y--)
+                buffer.write((char*)maskImage.scanLine(y), maskImage.bytesPerLine());
+        }
+
+        if (writeIconDir(device, id)) {
+            int i;
+            bool bOK = true;
+            for (i = 0; i < id.idCount && bOK; i++) {
+                bOK = writeIconDirEntry(device, entries[i]);
+            }
+            if (bOK) {
+                for (i = 0; i < id.idCount && bOK; i++) {
+                    bOK = writeBMPInfoHeader(device, bmpHeaders[i]);
+                    bOK &= (device->write(imageData[i]) == (int) imageData[i].size());
+                }
+                retValue = bOK;
+            }
+        }
+
+        delete [] entries;
+        delete [] bmpHeaders;
+        delete [] imageData;
+
+    }
+    return retValue;
+}
+
+/*!
+    Constructs an instance of QtIcoHandler initialized to use \a device.
+*/
+QtCurHandler::QtCurHandler(QIODevice *device)
+{
+    m_currentIconIndex = 0;
+    setDevice(device);
+    m_pCURReader = new CURReader(device);
+}
+
+/*!
+    Destructor for QtIcoHandler.
+*/
+QtCurHandler::~QtCurHandler()
+{
+    delete m_pCURReader;
+}
+
+QVariant QtCurHandler::option(ImageOption option) const
+{
+    if (option == Size) {
+        QIODevice *device = QImageIOHandler::device();
+        qint64 oldPos = device->pos();
+        ICONDIRENTRY iconEntry;
+        if (device->seek(oldPos + ICONDIR_SIZE + (m_currentIconIndex * ICONDIRENTRY_SIZE))) {
+            if (readIconDirEntry(device, &iconEntry)) {
+                device->seek(oldPos);
+                return QSize(iconEntry.bWidth, iconEntry.bHeight);
+            }
+        }
+        if (!device->isSequential())
+            device->seek(oldPos);
+    }
+    return QVariant();
+}
+
+bool QtCurHandler::supportsOption(ImageOption option) const
+{
+    return option == Size;
+}
+
+/*!
+ * Verifies if some values (magic bytes) are set as expected in the header of the file.
+ * If the magic bytes were found, it is assumed that the QtIcoHandler can read the file.
+ *
+ */
+bool QtCurHandler::canRead() const
+{
+    bool bCanRead = false;
+    QIODevice *device = QImageIOHandler::device();
+    if (device) {
+        bCanRead = CURReader::canRead(device);
+        if (bCanRead)
+            setFormat("ico");
+    } else {
+        qWarning("QtCurHandler::canRead() called with no device");
+    }
+    return bCanRead;
+}
+
+/*! This static function is used by the plugin code, and is provided for convenience only.
+    \a device must be an opened device with pointing to the start of the header data of the ICO file.
+*/
+bool QtCurHandler::canRead(QIODevice *device)
+{
+    Q_ASSERT(device);
+    return CURReader::canRead(device);
+}
+
+/*! \reimp
+
+*/
+bool QtCurHandler::read(QImage *image)
+{
+    bool bSuccess = false;
+    QImage img = m_pCURReader->iconAt(m_currentIconIndex);
+
+    // Make sure we only write to \a image when we succeed.
+    if (!img.isNull()) {
+        bSuccess = true;
+        *image = img;
+    }
+
+    return bSuccess;
+}
+
+
+/*! \reimp
+
+*/
+bool QtCurHandler::write(const QImage &image)
+{
+    QIODevice *device = QImageIOHandler::device();
+    QList<QImage> imgs;
+    imgs.append(image);
+    return CURReader::write(device, imgs);
+}
+
+/*!
+ * Return the common identifier of the format.
+ * For ICO format this will return "ico".
+ */
+QByteArray QtCurHandler::name() const
+{
+    return "cur";
+}
+
+
+/*! \reimp
+
+*/
+int QtCurHandler::imageCount() const
+{
+    return m_pCURReader->count();
+}
+
+/*! \reimp
+
+*/
+bool QtCurHandler::jumpToImage(int imageNumber)
+{
+    if (imageNumber < imageCount()) {
+        m_currentIconIndex = imageNumber;
+    }
+
+    return (imageNumber < imageCount()) ? true : false;
+}
+
+/*! \reimp
+
+*/
+bool QtCurHandler::jumpToNextImage()
+{
+    return jumpToImage(m_currentIconIndex + 1);
+}
+
+QT_END_NAMESPACE
+
diff -Nbaur qt/qtbase/src/plugins/imageformats/cur/qcurhandler.h qt.new/qtbase/src/plugins/imageformats/cur/qcurhandler.h
--- qt/qtbase/src/plugins/imageformats/cur/qcurhandler.h	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/imageformats/cur/qcurhandler.h	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,45 @@
+/*
+ * qcurhandler.h
+ *
+ *  Created on: Jan 11, 2013
+ *      Author: mike
+ */
+
+#ifndef QCURHANDLER_H_
+#define QCURHANDLER_H_
+
+#include <QtGui/QImageIOHandler>
+
+QT_BEGIN_NAMESPACE
+
+class CURReader;
+class QtCurHandler : public QImageIOHandler
+{
+public:
+	QtCurHandler(QIODevice *device);
+    virtual ~QtCurHandler();
+
+    bool canRead() const;
+    bool read(QImage *image);
+    bool write(const QImage &image);
+
+    QByteArray name() const;
+
+    int imageCount() const;
+    bool jumpToImage(int imageNumber);
+    bool jumpToNextImage();
+
+    static bool canRead(QIODevice *device);
+
+    bool supportsOption(ImageOption option) const;
+    QVariant option(ImageOption option) const;
+
+private:
+    int m_currentIconIndex;
+    CURReader *m_pCURReader;
+
+};
+
+
+
+#endif /* QCURHANDLER_H_ */
diff -Nbaur qt/qtbase/src/plugins/imageformats/imageformats.pro qt.new/qtbase/src/plugins/imageformats/imageformats.pro
--- qt/qtbase/src/plugins/imageformats/imageformats.pro	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/imageformats/imageformats.pro	2015-12-17 16:26:56.000000000 +0100
@@ -3,3 +3,4 @@
 !contains(QT_CONFIG, no-jpeg):!contains(QT_CONFIG, jpeg):SUBDIRS += jpeg
 !contains(QT_CONFIG, no-gif):!contains(QT_CONFIG, gif):SUBDIRS += gif
 !contains(QT_CONFIG, no-ico):SUBDIRS += ico
+!contains(QT_CONFIG, no-cur):SUBDIRS += cur
diff -Nbaur qt/qtbase/src/plugins/platforms/cocoa/cocoa.pro qt.new/qtbase/src/plugins/platforms/cocoa/cocoa.pro
--- qt/qtbase/src/plugins/platforms/cocoa/cocoa.pro	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/cocoa/cocoa.pro	2015-12-17 16:26:56.000000000 +0100
@@ -39,7 +39,9 @@
     qcocoasystemtrayicon.mm \
     qcocoaintrospection.mm \
     qcocoakeymapper.mm \
-    qcocoamimetypes.mm
+    qcocoamimetypes.mm \
+    qcocoaoffscreencommon.mm \
+    qcocoaoffscreenwindow.mm
 
 SOURCES += messages.cpp
 
@@ -76,7 +78,9 @@
     qcocoaintrospection.h \
     qcocoakeymapper.h \
     messages.h \
-    qcocoamimetypes.h
+    qcocoamimetypes.h \
+    qcocoaoffscreencommon.h \
+    qcocoaoffscreenwindow.h
 
 contains(QT_CONFIG, opengl.*) {
     OBJECTIVE_SOURCES += qcocoaglcontext.mm
diff -Nbaur qt/qtbase/src/plugins/platforms/cocoa/qcocoaintegration.h qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaintegration.h
--- qt/qtbase/src/plugins/platforms/cocoa/qcocoaintegration.h	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaintegration.h	2015-12-17 16:26:56.000000000 +0100
@@ -46,6 +46,7 @@
 #include "qcocoadrag.h"
 #include "qcocoaservices.h"
 #include "qcocoakeymapper.h"
+#include "qcocoaoffscreencommon.h"
 
 #include <QtCore/QScopedPointer>
 #include <qpa/qplatformintegration.h>
@@ -117,7 +118,7 @@
     QCocoaInputContext *inputContext() const;
     QCocoaAccessibility *accessibility() const;
     QCocoaClipboard *clipboard() const;
-    QCocoaDrag *drag() const;
+    QPlatformDrag *drag() const;
 
     QStringList themeNames() const;
     QPlatformTheme *createPlatformTheme(const QString &name) const;
@@ -159,6 +160,8 @@
 
     QHash<QWindow *, NSToolbar *> mToolbars;
     QList<QCocoaWindow *> m_popupWindowStack;
+
+    QCocoaOffscreenScreen *mOffscreenScreen;
 };
 
 QT_END_NAMESPACE
diff -Nbaur qt/qtbase/src/plugins/platforms/cocoa/qcocoaintegration.mm qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaintegration.mm
--- qt/qtbase/src/plugins/platforms/cocoa/qcocoaintegration.mm	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaintegration.mm	2015-12-17 16:26:56.000000000 +0100
@@ -47,6 +47,7 @@
 #include "qcocoainputcontext.h"
 #include "qcocoamimetypes.h"
 #include "qcocoaaccessibility.h"
+#include "qcocoaoffscreenwindow.h"
 
 #include <qpa/qplatformaccessibility.h>
 #include <QtCore/qcoreapplication.h>
@@ -257,6 +258,7 @@
     , mNativeInterface(new QCocoaNativeInterface)
     , mServices(new QCocoaServices)
     , mKeyboardMapper(new QCocoaKeyMapper)
+    , mOffscreenScreen(NULL)
 {
     if (mInstance != 0)
         qWarning("Creating multiple Cocoa platform integrations is not supported");
@@ -334,6 +336,10 @@
         destroyScreen(mScreens.takeLast());
     }
 
+    if (mOffscreenScreen) {
+        delete mOffscreenScreen;
+    }
+
     clearToolbars();
 }
 
@@ -352,8 +358,13 @@
     if ([screens count] == 0)
         if ([NSScreen mainScreen])
            [screens addObject:[NSScreen mainScreen]];
-    if ([screens count] == 0)
+    if ([screens count] == 0) {
+        if (QCoreApplication::testAttribute(Qt::AA_MacUseOffscreenScreen) && !mOffscreenScreen) {
+            mOffscreenScreen = new QCocoaOffscreenScreen();
+            screenAdded(mOffscreenScreen);
+        }
         return;
+    }
     QSet<QCocoaScreen*> remainingScreens = QSet<QCocoaScreen*>::fromList(mScreens);
     QList<QPlatformScreen *> siblings;
     uint screenCount = [screens count];
@@ -410,18 +421,22 @@
 {
     switch (cap) {
     case ThreadedPixmaps:
+    case MultipleWindows:
+    	return true;
 #ifndef QT_NO_OPENGL
     case OpenGL:
     case ThreadedOpenGL:
     case BufferQueueingOpenGL:
+    	return true;
 #endif
     case WindowMasks:
-    case MultipleWindows:
     case ForeignWindows:
     case RasterGLSurface:
     case ApplicationState:
     case ApplicationIcon:
+        if (!QCoreApplication::testAttribute(Qt::AA_MacUseOffscreenScreen) && !mOffscreenScreen)
         return true;
+        return false;
     default:
         return QPlatformIntegration::hasCapability(cap);
     }
@@ -429,6 +444,11 @@
 
 QPlatformWindow *QCocoaIntegration::createPlatformWindow(QWindow *window) const
 {
+    if(QCoreApplication::testAttribute(Qt::AA_MacUseOffscreenScreen) && mOffscreenScreen) {
+        QPlatformWindow *w = new QCocoaOffscreenWindow(window);
+        w->requestActivateWindow();
+        return w;
+    }
     return new QCocoaWindow(window);
 }
 
@@ -445,6 +465,9 @@
 
 QPlatformBackingStore *QCocoaIntegration::createPlatformBackingStore(QWindow *window) const
 {
+    if(QCoreApplication::testAttribute(Qt::AA_MacUseOffscreenScreen) && mOffscreenScreen) {
+        return new QCocoaOffscreenBackingStore(window);
+    }
     return new QCocoaBackingStore(window);
 }
 
@@ -482,8 +505,11 @@
     return mCocoaClipboard;
 }
 
-QCocoaDrag *QCocoaIntegration::drag() const
+QPlatformDrag *QCocoaIntegration::drag() const
 {
+    if(QCoreApplication::testAttribute(Qt::AA_UseSimpleDnD)) {
+        return QPlatformIntegration::drag();
+    }
     return mCocoaDrag.data();
 }
 
diff -Nbaur qt/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreencommon.h qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreencommon.h
--- qt/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreencommon.h	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreencommon.h	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,71 @@
+/*
+ * qcocoaoffscreen.h
+ *
+ *  Created on: Aug 21, 2014
+ *      Author: mike
+ */
+
+#ifndef QCOCOAOFFSCREEN_H_
+#define QCOCOAOFFSCREEN_H_
+
+#include <qpa/qplatformbackingstore.h>
+#include <qpa/qplatformdrag.h>
+#include <qpa/qplatformintegration.h>
+#include <qpa/qplatformscreen.h>
+#include <qpa/qplatformwindow.h>
+
+#include <qscopedpointer.h>
+#include <qimage.h>
+#include <qhash.h>
+
+QT_BEGIN_NAMESPACE
+
+class QCocoaOffscreenScreen : public QPlatformScreen
+{
+public:
+	QCocoaOffscreenScreen();
+	virtual ~QCocoaOffscreenScreen();
+
+	QRect geometry() const { return m_geometry; }
+	int depth() const { return 32; }
+	QImage::Format format() const { return QImage::Format_RGB32; }
+    QSizeF physicalSize() const { return m_physicalSize; }
+    QPlatformCursor *cursor() const { return m_cursor.data(); }
+
+    QPixmap grabWindow(WId window, int x, int y, int width, int height) const;
+
+    static QPlatformWindow *windowContainingCursor;
+
+public:
+	QRect m_geometry;
+	QSizeF m_physicalSize;
+    QScopedPointer<QPlatformCursor> m_cursor;
+};
+
+class QCocoaOffscreenBackingStore : public QPlatformBackingStore
+{
+public:
+	QCocoaOffscreenBackingStore(QWindow *window);
+    ~QCocoaOffscreenBackingStore();
+
+    QPaintDevice *paintDevice();
+    void flush(QWindow *window, const QRegion &region, const QPoint &offset);
+    void resize(const QSize &size, const QRegion &staticContents);
+    bool scroll(const QRegion &area, int dx, int dy);
+
+    QPixmap grabWindow(WId window, const QRect &rect) const;
+
+    static QCocoaOffscreenBackingStore *backingStoreForWinId(WId id);
+
+private:
+    void clearHash();
+
+    QImage m_image;
+    QHash<WId, QRect> m_windowAreaHash;
+
+    static QHash<WId, QCocoaOffscreenBackingStore *> m_backingStoreForWinIdHash;
+};
+
+QT_END_NAMESPACE
+
+#endif /* QCOCOAOFFSCREEN_H_ */
diff -Nbaur qt/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreencommon.mm qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreencommon.mm
--- qt/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreencommon.mm	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreencommon.mm	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,198 @@
+#include "qcocoaoffscreencommon.h"
+#include "qcocoaoffscreenwindow.h"
+
+#include <QtGui/private/qpixmap_raster_p.h>
+#include <QtGui/private/qguiapplication_p.h>
+
+#include <qpa/qplatformcursor.h>
+#include <qpa/qplatformwindow.h>
+
+QT_BEGIN_NAMESPACE
+
+QPlatformWindow *QCocoaOffscreenScreen::windowContainingCursor = 0;
+
+class QCocoaOffscreenCursor : public QPlatformCursor
+{
+public:
+	QCocoaOffscreenCursor() : m_pos(10, 10) {}
+
+    QPoint pos() const { return m_pos; }
+    void setPos(const QPoint &pos)
+    {
+        m_pos = pos;
+        QWindowList wl = QGuiApplication::topLevelWindows();
+        QWindow *containing = 0;
+        foreach (QWindow *w, wl) {
+            if (w->type() != Qt::Desktop && w->isExposed() && w->geometry().contains(pos)) {
+                containing = w;
+                break;
+            }
+        }
+
+        QPoint local = pos;
+        if (containing)
+            local -= containing->position();
+
+        QWindow *previous = QCocoaOffscreenScreen::windowContainingCursor ? QCocoaOffscreenScreen::windowContainingCursor->window() : 0;
+
+        if (containing != previous)
+            QWindowSystemInterface::handleEnterLeaveEvent(containing, previous, local, pos);
+
+        QWindowSystemInterface::handleMouseEvent(containing, local, pos, QGuiApplication::mouseButtons(), QGuiApplication::keyboardModifiers());
+
+        QCocoaOffscreenScreen::windowContainingCursor = containing ? containing->handle() : 0;
+    }
+
+    void changeCursor(QCursor *windowCursor, QWindow *window)
+    {
+        Q_UNUSED(windowCursor);
+        Q_UNUSED(window);
+    }
+
+private:
+    QPoint m_pos;
+};
+
+QCocoaOffscreenScreen::QCocoaOffscreenScreen()
+	: m_geometry(0, 0, 1280, 1024)
+	, m_cursor(new QCocoaOffscreenCursor)
+{
+	int dpi = 72;
+    qreal physicalWidth = m_geometry.width()*25.4/dpi;
+    qreal physicalHeight = m_geometry.height()*25.4/dpi;
+
+	m_physicalSize = QSizeF(physicalWidth, physicalHeight);
+}
+
+QCocoaOffscreenScreen::~QCocoaOffscreenScreen()
+{
+
+}
+
+QPixmap QCocoaOffscreenScreen::grabWindow(WId id, int x, int y, int width, int height) const
+{
+    QRect rect(x, y, width, height);
+
+    QCocoaOffscreenWindow *window = QCocoaOffscreenWindow::windowForWinId(id);
+    if (!window || window->window()->type() == Qt::Desktop) {
+        QWindowList wl = QGuiApplication::topLevelWindows();
+        QWindow *containing = 0;
+        foreach (QWindow *w, wl) {
+            if (w->type() != Qt::Desktop && w->isExposed() && w->geometry().contains(rect)) {
+                containing = w;
+                break;
+            }
+        }
+
+        if (!containing)
+            return QPixmap();
+
+        id = containing->winId();
+        rect = rect.translated(-containing->geometry().topLeft());
+    }
+
+    QCocoaOffscreenBackingStore *store = QCocoaOffscreenBackingStore::backingStoreForWinId(id);
+    if (store)
+        return store->grabWindow(id, rect);
+    return QPixmap();
+}
+
+QCocoaOffscreenBackingStore::QCocoaOffscreenBackingStore(QWindow *window)
+    : QPlatformBackingStore(window)
+{
+}
+
+QCocoaOffscreenBackingStore::~QCocoaOffscreenBackingStore()
+{
+    clearHash();
+}
+
+QPaintDevice *QCocoaOffscreenBackingStore::paintDevice()
+{
+    return &m_image;
+}
+
+void QCocoaOffscreenBackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
+{
+    Q_UNUSED(region);
+
+    if (m_image.size().isEmpty())
+        return;
+
+    QSize imageSize = m_image.size();
+
+    QRegion clipped = QRect(0, 0, window->width(), window->height());
+    clipped &= QRect(0, 0, imageSize.width(), imageSize.height()).translated(-offset);
+
+    QRect bounds = clipped.boundingRect().translated(offset);
+
+    if (bounds.isNull())
+        return;
+
+    WId id = window->winId();
+
+    m_windowAreaHash[id] = bounds;
+    m_backingStoreForWinIdHash[id] = this;
+}
+
+void QCocoaOffscreenBackingStore::resize(const QSize &size, const QRegion &)
+{
+    QImage::Format format = QGuiApplication::primaryScreen()->handle()->format();
+    if (m_image.size() != size)
+        m_image = QImage(size, format);
+    clearHash();
+}
+
+extern void qt_scrollRectInImage(QImage &img, const QRect &rect, const QPoint &offset);
+
+bool QCocoaOffscreenBackingStore::scroll(const QRegion &area, int dx, int dy)
+{
+    if (m_image.isNull())
+        return false;
+
+    const QVector<QRect> rects = area.rects();
+    for (int i = 0; i < rects.size(); ++i)
+        qt_scrollRectInImage(m_image, rects.at(i), QPoint(dx, dy));
+
+    return true;
+}
+
+QPixmap QCocoaOffscreenBackingStore::grabWindow(WId window, const QRect &rect) const
+{
+    QRect area = m_windowAreaHash.value(window, QRect());
+    if (area.isNull())
+        return QPixmap();
+
+    QRect adjusted = rect;
+    if (adjusted.width() <= 0)
+        adjusted.setWidth(area.width());
+    if (adjusted.height() <= 0)
+        adjusted.setHeight(area.height());
+
+    adjusted = adjusted.translated(area.topLeft()) & area;
+
+    if (adjusted.isEmpty())
+        return QPixmap();
+
+    return QPixmap::fromImage(m_image.copy(adjusted));
+}
+
+QCocoaOffscreenBackingStore *QCocoaOffscreenBackingStore::backingStoreForWinId(WId id)
+{
+    return m_backingStoreForWinIdHash.value(id, 0);
+}
+
+void QCocoaOffscreenBackingStore::clearHash()
+{
+    QList<WId> ids = m_windowAreaHash.keys();
+    foreach (WId id, ids) {
+        QHash<WId, QCocoaOffscreenBackingStore *>::iterator it = m_backingStoreForWinIdHash.find(id);
+        if (it.value() == this)
+            m_backingStoreForWinIdHash.remove(id);
+    }
+    m_windowAreaHash.clear();
+}
+
+QHash<WId, QCocoaOffscreenBackingStore *> QCocoaOffscreenBackingStore::m_backingStoreForWinIdHash;
+
+QT_END_NAMESPACE
diff -Nbaur qt/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreenwindow.h qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreenwindow.h
--- qt/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreenwindow.h	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreenwindow.h	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,52 @@
+/*
+ * qcocoaoffscreenwindow.h
+ *
+ *  Created on: Aug 21, 2014
+ *      Author: mike
+ */
+
+#ifndef QCOCOAOFFSCREENWINDOW_H_
+#define QCOCOAOFFSCREENWINDOW_H_
+
+#include <qpa/qplatformbackingstore.h>
+#include <qpa/qplatformwindow.h>
+
+#include <qhash.h>
+
+QT_BEGIN_NAMESPACE
+
+class QCocoaOffscreenWindow : public QPlatformWindow
+{
+public:
+	QCocoaOffscreenWindow(QWindow *window);
+    ~QCocoaOffscreenWindow();
+
+    void setGeometry(const QRect &rect);
+    void setWindowState(Qt::WindowState state);
+
+    QMargins frameMargins() const;
+
+    void setVisible(bool visible);
+    void requestActivateWindow();
+
+    WId winId() const;
+
+    static QCocoaOffscreenWindow *windowForWinId(WId id);
+
+private:
+    void setFrameMarginsEnabled(bool enabled);
+    void setGeometryImpl(const QRect &rect);
+
+    QRect m_normalGeometry;
+    QMargins m_margins;
+    bool m_positionIncludesFrame;
+    bool m_visible;
+    bool m_pendingGeometryChangeOnShow;
+    WId m_winId;
+
+    static QHash<WId, QCocoaOffscreenWindow *> m_windowForWinIdHash;
+};
+
+QT_END_NAMESPACE
+
+#endif /* QCOCOAOFFSCREENWINDOW_H_ */
diff -Nbaur qt/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreenwindow.mm qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreenwindow.mm
--- qt/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreenwindow.mm	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/cocoa/qcocoaoffscreenwindow.mm	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,158 @@
+#include "qcocoaoffscreenwindow.h"
+#include "qcocoaoffscreencommon.h"
+
+#include <qpa/qplatformscreen.h>
+#include <qpa/qwindowsysteminterface.h>
+
+#include <private/qwindow_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QCocoaOffscreenWindow::QCocoaOffscreenWindow(QWindow *window)
+    : QPlatformWindow(window)
+    , m_positionIncludesFrame(false)
+    , m_visible(false)
+    , m_pendingGeometryChangeOnShow(true)
+{
+    if (window->windowState() == Qt::WindowNoState)
+        setGeometry(window->geometry());
+    else
+        setWindowState(window->windowState());
+
+    QWindowSystemInterface::flushWindowSystemEvents();
+
+    static WId counter = 0;
+    m_winId = ++counter;
+
+    m_windowForWinIdHash[m_winId] = this;
+}
+
+QCocoaOffscreenWindow::~QCocoaOffscreenWindow()
+{
+    if (QCocoaOffscreenScreen::windowContainingCursor == this)
+        QCocoaOffscreenScreen::windowContainingCursor = 0;
+    m_windowForWinIdHash.remove(m_winId);
+}
+
+void QCocoaOffscreenWindow::setGeometry(const QRect &rect)
+{
+    if (window()->windowState() != Qt::WindowNoState)
+        return;
+
+    m_positionIncludesFrame = qt_window_private(window())->positionPolicy == QWindowPrivate::WindowFrameInclusive;
+
+    setFrameMarginsEnabled(true);
+    setGeometryImpl(rect);
+
+    m_normalGeometry = geometry();
+}
+
+void QCocoaOffscreenWindow::setGeometryImpl(const QRect &rect)
+{
+    QRect adjusted = rect;
+    if (adjusted.width() <= 0)
+        adjusted.setWidth(1);
+    if (adjusted.height() <= 0)
+        adjusted.setHeight(1);
+
+    if (m_positionIncludesFrame) {
+        adjusted.translate(m_margins.left(), m_margins.top());
+    } else {
+        // make sure we're not placed off-screen
+        if (adjusted.left() < m_margins.left())
+            adjusted.translate(m_margins.left(), 0);
+        if (adjusted.top() < m_margins.top())
+            adjusted.translate(0, m_margins.top());
+    }
+
+    QPlatformWindow::setGeometry(adjusted);
+
+    if (m_visible) {
+        QWindowSystemInterface::handleGeometryChange(window(), adjusted);
+        QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(), adjusted.size()));
+    } else {
+        m_pendingGeometryChangeOnShow = true;
+    }
+}
+
+void QCocoaOffscreenWindow::setVisible(bool visible)
+{
+    if (visible == m_visible)
+        return;
+
+    if (visible) {
+        if (window()->type() != Qt::ToolTip)
+            QWindowSystemInterface::handleWindowActivated(window());
+
+        if (m_pendingGeometryChangeOnShow) {
+            m_pendingGeometryChangeOnShow = false;
+            QWindowSystemInterface::handleGeometryChange(window(), geometry());
+        }
+    }
+
+    if (visible) {
+        QRect rect(QPoint(), geometry().size());
+        QWindowSystemInterface::handleExposeEvent(window(), rect);
+    } else {
+        QWindowSystemInterface::handleExposeEvent(window(), QRegion());
+    }
+
+    m_visible = visible;
+}
+
+void QCocoaOffscreenWindow::requestActivateWindow()
+{
+    if (m_visible)
+        QWindowSystemInterface::handleWindowActivated(window());
+}
+
+WId QCocoaOffscreenWindow::winId() const
+{
+    return m_winId;
+}
+
+QMargins QCocoaOffscreenWindow::frameMargins() const
+{
+    return m_margins;
+}
+
+void QCocoaOffscreenWindow::setFrameMarginsEnabled(bool enabled)
+{
+    if (enabled && !(window()->flags() & Qt::FramelessWindowHint))
+        m_margins = QMargins(2, 2, 2, 2);
+    else
+        m_margins = QMargins(0, 0, 0, 0);
+}
+
+void QCocoaOffscreenWindow::setWindowState(Qt::WindowState state)
+{
+    setFrameMarginsEnabled(state != Qt::WindowFullScreen);
+    m_positionIncludesFrame = false;
+
+    switch (state) {
+    case Qt::WindowFullScreen:
+        setGeometryImpl(screen()->geometry());
+        break;
+    case Qt::WindowMaximized:
+        setGeometryImpl(screen()->availableGeometry().adjusted(m_margins.left(), m_margins.top(), -m_margins.right(), -m_margins.bottom()));
+        break;
+    case Qt::WindowMinimized:
+        break;
+    case Qt::WindowNoState:
+        setGeometryImpl(m_normalGeometry);
+        break;
+    default:
+        break;
+    }
+
+    QWindowSystemInterface::handleWindowStateChanged(window(), state);
+}
+
+QCocoaOffscreenWindow *QCocoaOffscreenWindow::windowForWinId(WId id)
+{
+    return m_windowForWinIdHash.value(id, 0);
+}
+
+QHash<WId, QCocoaOffscreenWindow *> QCocoaOffscreenWindow::m_windowForWinIdHash;
+
+QT_END_NAMESPACE
diff -Nbaur qt/qtbase/src/plugins/platforms/cocoa/qnsview.mm qt.new/qtbase/src/plugins/platforms/cocoa/qnsview.mm
--- qt/qtbase/src/plugins/platforms/cocoa/qnsview.mm	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/cocoa/qnsview.mm	2015-12-17 16:26:56.000000000 +0100
@@ -715,8 +715,10 @@
     [targetView convertFromScreen:[self screenMousePoint:theEvent] toWindowPoint:&qtWindowPoint andScreenPoint:&qtScreenPoint];
     ulong timestamp = [theEvent timestamp] * 1000;
 
-    QCocoaDrag* nativeDrag = QCocoaIntegration::instance()->drag();
+    QCocoaDrag* nativeDrag = dynamic_cast<QCocoaDrag*>(QCocoaIntegration::instance()->drag());
+    if(nativeDrag) {
     nativeDrag->setLastMouseEvent(theEvent, self);
+    }
 
     Qt::KeyboardModifiers keyboardModifiers = [QNSView convertKeyModifiers:[theEvent modifierFlags]];
     QWindowSystemInterface::handleMouseEvent(targetView->m_window, timestamp, qtWindowPoint, qtScreenPoint, m_buttons, keyboardModifiers);
@@ -1835,8 +1837,8 @@
 - (NSDragOperation) draggingSourceOperationMaskForLocal:(BOOL)isLocal
 {
     Q_UNUSED(isLocal);
-    QCocoaDrag* nativeDrag = QCocoaIntegration::instance()->drag();
-    return qt_mac_mapDropActions(nativeDrag->currentDrag()->supportedActions());
+    QPlatformDrag* platformDrag = QCocoaIntegration::instance()->drag();
+    return qt_mac_mapDropActions(platformDrag->currentDrag()->supportedActions());
 }
 
 - (BOOL) ignoreModifierKeysWhileDragging
@@ -1926,11 +1928,14 @@
     QGuiApplicationPrivate::modifier_buttons = [QNSView convertKeyModifiers: [[NSApp currentEvent] modifierFlags]];
 
     QPlatformDragQtResponse response(false, Qt::IgnoreAction, QRect());
-    QCocoaDrag* nativeDrag = QCocoaIntegration::instance()->drag();
-    if (nativeDrag->currentDrag()) {
+    QPlatformDrag* platformDrag = QCocoaIntegration::instance()->drag();
+    if (platformDrag->currentDrag()) {
         // The drag was started from within the application
+        QCocoaDrag* nativeDrag = dynamic_cast<QCocoaDrag*>(platformDrag);
+        if (nativeDrag) {
         response = QWindowSystemInterface::handleDrag(target, nativeDrag->platformDropData(), mapWindowCoordinates(m_window, target, qt_windowPoint), qtAllowed);
         [self updateCursorFromDragResponse:response drag:nativeDrag];
+        }    
     } else {
         QCocoaDropData mimeData([sender draggingPasteboard]);
         response = QWindowSystemInterface::handleDrag(target, &mimeData, mapWindowCoordinates(m_window, target, qt_windowPoint), qtAllowed);
@@ -1964,18 +1969,23 @@
     Qt::DropActions qtAllowed = qt_mac_mapNSDragOperations([sender draggingSourceOperationMask]);
 
     QPlatformDropQtResponse response(false, Qt::IgnoreAction);
-    QCocoaDrag* nativeDrag = QCocoaIntegration::instance()->drag();
-    if (nativeDrag->currentDrag()) {
+    QPlatformDrag* platformDrag = QCocoaIntegration::instance()->drag();
+    if (platformDrag->currentDrag()) {
         // The drag was started from within the application
+        QCocoaDrag* nativeDrag = dynamic_cast<QCocoaDrag*>(platformDrag);
+        if (nativeDrag) {
         response = QWindowSystemInterface::handleDrop(target, nativeDrag->platformDropData(), mapWindowCoordinates(m_window, target, qt_windowPoint), qtAllowed);
+        }    
     } else {
         QCocoaDropData mimeData([sender draggingPasteboard]);
         response = QWindowSystemInterface::handleDrop(target, &mimeData, mapWindowCoordinates(m_window, target, qt_windowPoint), qtAllowed);
     }
     if (response.isAccepted()) {
-        QCocoaDrag* nativeDrag = QCocoaIntegration::instance()->drag();
+        QCocoaDrag* nativeDrag = dynamic_cast<QCocoaDrag*>(platformDrag);
+        if (nativeDrag) {
         nativeDrag->setAcceptedAction(response.acceptedAction());
     }
+    }
     return response.isAccepted();
 }
 
diff -Nbaur qt/qtbase/src/plugins/platforms/windows/qwindowsfontdatabase.cpp qt.new/qtbase/src/plugins/platforms/windows/qwindowsfontdatabase.cpp
--- qt/qtbase/src/plugins/platforms/windows/qwindowsfontdatabase.cpp	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/windows/qwindowsfontdatabase.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -157,7 +157,7 @@
         Q_ASSERT(tagName.size() == 4);
         quint32 tagId = *(reinterpret_cast<const quint32 *>(tagName.constData()));
         const size_t fontDataSize = m_fontData.size();
-        if (Q_UNLIKELY(fontDataSize < sizeof(OffsetSubTable)))
+        if (Q_UNLIKELY(fontDataSize < sizeof(OffsetSubTable) + sizeof(TableDirectory)))
             return 0;
 
         OffsetSubTable *offsetSubTable = reinterpret_cast<OffsetSubTable *>(m_fontData.data());
diff -Nbaur qt/qtbase/src/plugins/platforms/xcb/qxcbconnection.cpp qt.new/qtbase/src/plugins/platforms/xcb/qxcbconnection.cpp
--- qt/qtbase/src/plugins/platforms/xcb/qxcbconnection.cpp	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/xcb/qxcbconnection.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -1437,6 +1437,11 @@
 
 #endif
 
+void QXcbConnection::flush()
+{
+    xcb_flush(m_connection);
+}
+
 void QXcbConnection::processXcbEvents()
 {
     int connection_error = xcb_connection_has_error(xcb_connection());
diff -Nbaur qt/qtbase/src/plugins/platforms/xcb/qxcbconnection.h qt.new/qtbase/src/plugins/platforms/xcb/qxcbconnection.h
--- qt/qtbase/src/plugins/platforms/xcb/qxcbconnection.h	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/xcb/qxcbconnection.h	2015-12-17 16:26:56.000000000 +0100
@@ -497,7 +497,7 @@
     bool event(QEvent *e) Q_DECL_OVERRIDE;
 
 public slots:
-    void flush() { xcb_flush(m_connection); }
+    void flush();
 
 private slots:
     void processXcbEvents();
diff -Nbaur qt/qtbase/src/plugins/platforms/xcb/qxcbintegration.cpp qt.new/qtbase/src/plugins/platforms/xcb/qxcbintegration.cpp
--- qt/qtbase/src/plugins/platforms/xcb/qxcbintegration.cpp	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/xcb/qxcbintegration.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -297,6 +297,9 @@
 #ifndef QT_NO_DRAGANDDROP
 QPlatformDrag *QXcbIntegration::drag() const
 {
+    if(QCoreApplication::testAttribute(Qt::AA_UseSimpleDnD)) {
+        return QPlatformIntegration::drag();
+    }
     return m_connections.at(0)->drag();
 }
 #endif
diff -Nbaur qt/qtbase/src/plugins/platforms/xcb/qxcbscreen.cpp qt.new/qtbase/src/plugins/platforms/xcb/qxcbscreen.cpp
--- qt/qtbase/src/plugins/platforms/xcb/qxcbscreen.cpp	2015-12-17 16:23:54.000000000 +0100
+++ qt.new/qtbase/src/plugins/platforms/xcb/qxcbscreen.cpp	2015-12-17 16:29:41.000000000 +0100
@@ -544,7 +544,9 @@
         for (; modesIter.rem; xcb_randr_mode_info_next(&modesIter)) {
             xcb_randr_mode_info_t *modeInfo = modesIter.data;
             if (modeInfo->id == mode) {
+                if (modeInfo->htotal * modeInfo->vtotal) {
                 m_refreshRate = modeInfo->dot_clock / (modeInfo->htotal * modeInfo->vtotal);
+                }    
                 m_mode = mode;
                 break;
             }
diff -Nbaur qt/qtbase/src/widgets/kernel/qdesktopwidget.cpp qt.new/qtbase/src/widgets/kernel/qdesktopwidget.cpp
--- qt/qtbase/src/widgets/kernel/qdesktopwidget.cpp	2015-12-17 16:23:55.000000000 +0100
+++ qt.new/qtbase/src/widgets/kernel/qdesktopwidget.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -36,6 +36,7 @@
 #include "qdesktopwidget_p.h"
 #include "qscreen.h"
 #include "qwidget_p.h"
+#include "qwindow.h"
 
 QT_BEGIN_NAMESPACE
 
@@ -73,6 +74,49 @@
         return rect;
 }
 
+bool QDesktopWidget::event(QEvent *event)
+{
+	Q_D(QDesktopWidget);
+	if(event->type() == QEvent::CursorChange) {
+		QWindow *win = reinterpret_cast<QWindow*>(d->topData()->window);
+		QObject *originator = property("__originator").value<QObject*>();
+		if(originator) {
+			QMetaObject::invokeMethod(originator, "cursorChanged", Qt::DirectConnection, Q_ARG(const QCursor&, (win ? win->cursor() : QCursor())));
+			return true;
+		}
+	}
+
+	return QWidget::event(event);
+}
+
+void QDesktopWidget::dragEnterEvent(QDragEnterEvent *event)
+{
+	QObject *originator = property("__originator").value<QObject*>();
+	if(originator)
+		QMetaObject::invokeMethod(originator, "event", Qt::DirectConnection, Q_ARG(QEvent*, event));
+}
+
+void QDesktopWidget::dragLeaveEvent(QDragLeaveEvent *event)
+{
+	QObject *originator = property("__originator").value<QObject*>();
+	if(originator)
+		QMetaObject::invokeMethod(originator, "event", Qt::DirectConnection, Q_ARG(QEvent*, event));
+}
+
+void QDesktopWidget::dragMoveEvent(QDragMoveEvent *event)
+{
+	QObject *originator = property("__originator").value<QObject*>();
+	if(originator)
+		QMetaObject::invokeMethod(originator, "event", Qt::DirectConnection, Q_ARG(QEvent*, event));
+}
+
+void QDesktopWidget::dropEvent(QDropEvent *event)
+{
+	QObject *originator = property("__originator").value<QObject*>();
+	if(originator)
+		QMetaObject::invokeMethod(originator, "event", Qt::DirectConnection, Q_ARG(QEvent*, event));
+}
+
 void QDesktopWidgetPrivate::_q_updateScreens()
 {
     Q_Q(QDesktopWidget);
diff -Nbaur qt/qtbase/src/widgets/kernel/qdesktopwidget.h qt.new/qtbase/src/widgets/kernel/qdesktopwidget.h
--- qt/qtbase/src/widgets/kernel/qdesktopwidget.h	2015-12-17 16:23:55.000000000 +0100
+++ qt.new/qtbase/src/widgets/kernel/qdesktopwidget.h	2015-12-17 16:26:56.000000000 +0100
@@ -79,6 +79,11 @@
     void screenCountChanged(int);
 
 protected:
+    bool event(QEvent *event);
+    void dragEnterEvent(QDragEnterEvent *event);
+    void dragLeaveEvent(QDragLeaveEvent *event);
+    void dragMoveEvent(QDragMoveEvent *event);
+    void dropEvent(QDropEvent *event);
     void resizeEvent(QResizeEvent *e) Q_DECL_OVERRIDE;
 
 private:
diff -Nbaur qt/qtwebkit/Source/WebCore/Target.pri qt.new/qtwebkit/Source/WebCore/Target.pri
--- qt/qtwebkit/Source/WebCore/Target.pri	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebCore/Target.pri	2015-12-17 16:26:56.000000000 +0100
@@ -3002,9 +3002,9 @@
             SOURCES += \
                 plugins/mac/PluginPackageMac.cpp
             OBJECTIVE_SOURCES += \
-                platform/text/mac/StringImplMac.mm \
-                platform/mac/WebCoreNSStringExtras.mm \
-                plugins/mac/PluginViewMac.mm
+                $$PWD/platform/text/mac/StringImplMac.mm \
+                $$PWD/platform/mac/WebCoreNSStringExtras.mm \
+                $$PWD/plugins/mac/PluginViewMac.mm
         } else {
             SOURCES += \
                 plugins/qt/PluginPackageQt.cpp \
diff -Nbaur qt/qtwebkit/Source/WebCore/WebCore.pri qt.new/qtwebkit/Source/WebCore/WebCore.pri
--- qt/qtwebkit/Source/WebCore/WebCore.pri	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebCore/WebCore.pri	2015-12-17 16:26:56.000000000 +0100
@@ -139,7 +139,7 @@
 enable?(NETSCAPE_PLUGIN_API) {
     unix {
         mac {
-            INCLUDEPATH += platform/mac
+            INCLUDEPATH += $$PWD/platform/mac
             # Note: XP_MACOSX is defined in npapi.h
         } else {
             xlibAvailable() {
diff -Nbaur qt/qtwebkit/Source/WebCore/page/SecurityOrigin.cpp qt.new/qtwebkit/Source/WebCore/page/SecurityOrigin.cpp
--- qt/qtwebkit/Source/WebCore/page/SecurityOrigin.cpp	2015-12-17 16:24:03.000000000 +0100
+++ qt.new/qtwebkit/Source/WebCore/page/SecurityOrigin.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -128,6 +128,8 @@
     , m_enforceFilePathSeparation(false)
     , m_needsDatabaseIdentifierQuirkForFiles(false)
     , m_deniedCORS(false)
+    , m_isSpecialSecurityOrigin(false)
+
 {
     // document.domain starts as m_host, but can be set by the DOM.
     m_domain = m_host;
@@ -140,6 +142,9 @@
 
     if (m_canLoadLocalResources)
         m_filePath = url.path(); // In case enforceFilePathSeparation() is called.
+
+    if (m_protocol == "qrc" && m_filePath.startsWith("/pdf.js/"))
+        m_isSpecialSecurityOrigin = true;
 }
 
 SecurityOrigin::SecurityOrigin()
@@ -155,6 +160,7 @@
     , m_enforceFilePathSeparation(false)
     , m_needsDatabaseIdentifierQuirkForFiles(false)
     , m_deniedCORS(false)
+    , m_isSpecialSecurityOrigin(false)
 {
 }
 
@@ -172,6 +178,7 @@
     , m_enforceFilePathSeparation(other->m_enforceFilePathSeparation)
     , m_needsDatabaseIdentifierQuirkForFiles(other->m_needsDatabaseIdentifierQuirkForFiles)
     , m_deniedCORS(other->m_deniedCORS)
+    , m_isSpecialSecurityOrigin(other->m_isSpecialSecurityOrigin)
 {
 }
 
@@ -303,9 +310,17 @@
 
     RefPtr<SecurityOrigin> targetOrigin = SecurityOrigin::create(url);
 
+    if (isSpecialSecurityOrigin()) {
+    	if (SecurityPolicy::isAccessWhiteListed(this, targetOrigin.get()))
+            return true;
+    }
+
     if (targetOrigin->isUnique())
         return false;
 
+    if (targetOrigin->isSpecialSecurityOrigin())
+        return true;
+
     // We call isSameSchemeHostPort here instead of canAccess because we want
     // to ignore document.domain effects.
     if (isSameSchemeHostPort(targetOrigin.get()))
diff -Nbaur qt/qtwebkit/Source/WebCore/page/SecurityOrigin.h qt.new/qtwebkit/Source/WebCore/page/SecurityOrigin.h
--- qt/qtwebkit/Source/WebCore/page/SecurityOrigin.h	2015-12-17 16:24:03.000000000 +0100
+++ qt.new/qtwebkit/Source/WebCore/page/SecurityOrigin.h	2015-12-17 16:26:56.000000000 +0100
@@ -174,6 +174,9 @@
     // addition, the SandboxOrigin flag is inherited by iframes.
     bool isUnique() const { return m_isUnique; }
 
+      
+    bool isSpecialSecurityOrigin() const { return m_isSpecialSecurityOrigin; }
+    
     // Marks a file:// origin as being in a domain defined by its path.
     // FIXME 81578: The naming of this is confusing. Files with restricted access to other local files
     // still can have other privileges that can be remembered, thereby not making them unique.
@@ -238,6 +241,7 @@
     bool m_enforceFilePathSeparation;
     bool m_needsDatabaseIdentifierQuirkForFiles;
     bool m_deniedCORS;
+    bool m_isSpecialSecurityOrigin;
 };
 
 } // namespace WebCore
diff -Nbaur qt/qtwebkit/Source/WebCore/platform/network/qt/CookieJarQt.cpp qt.new/qtwebkit/Source/WebCore/platform/network/qt/CookieJarQt.cpp
--- qt/qtwebkit/Source/WebCore/platform/network/qt/CookieJarQt.cpp	2015-12-17 16:24:04.000000000 +0100
+++ qt.new/qtwebkit/Source/WebCore/platform/network/qt/CookieJarQt.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -117,16 +117,33 @@
     return !!jar;
 }
 
-bool getRawCookies(const NetworkStorageSession& session, const KURL& /*firstParty*/, const KURL& /*url*/, Vector<Cookie>& rawCookies)
+bool getRawCookies(const NetworkStorageSession& session, const KURL& /*firstParty*/, const KURL& url, Vector<Cookie>& rawCookies)
 {
-    // FIXME: Not yet implemented
-    rawCookies.clear();
-    return false; // return true when implemented
+    QNetworkCookieJar* jar = session.context() ? session.context()->networkAccessManager()->cookieJar() : SharedCookieJarQt::shared();
+    if (!jar)
+        return false;
+    
+    QList<QNetworkCookie> cookies = jar->cookiesForUrl(QUrl(url));
+    if(cookies.isEmpty())
+        return true;
+        
+    foreach (QNetworkCookie networkCookie, cookies)
+		rawCookies.append(Cookie(QString::fromLatin1(networkCookie.name().constData()),
+								 QString::fromLatin1(networkCookie.value().constData()),
+								 networkCookie.domain(), networkCookie.path(),
+								 double(networkCookie.expirationDate().toMSecsSinceEpoch()),
+								 networkCookie.isHttpOnly(), networkCookie.isSecure(), networkCookie.isSessionCookie()));
+
+	return true;
 }
 
-void deleteCookie(const NetworkStorageSession&, const KURL&, const String&)
+void deleteCookie(const NetworkStorageSession& session, const KURL& url, const String& cookieName)
 {
-    // FIXME: Not yet implemented
+    QNetworkCookieJar* jar = session.context() ? session.context()->networkAccessManager()->cookieJar() : SharedCookieJarQt::shared();
+    if (!jar)
+        return;
+
+    QMetaObject::invokeMethod(jar, "deleteCookieForUrl", Qt::DirectConnection, Q_ARG(const QUrl&, QUrl(url)), Q_ARG(const QString&, QString(cookieName)));
 }
 
 void getHostnamesWithCookies(const NetworkStorageSession& session, HashSet<String>& hostnames)
diff -Nbaur qt/qtwebkit/Source/WebCore/plugins/PluginStream.cpp qt.new/qtwebkit/Source/WebCore/plugins/PluginStream.cpp
--- qt/qtwebkit/Source/WebCore/plugins/PluginStream.cpp	2015-12-17 16:24:04.000000000 +0100
+++ qt.new/qtwebkit/Source/WebCore/plugins/PluginStream.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -146,8 +146,14 @@
         String statusLine = "HTTP " + String::number(m_resourceResponse.httpStatusCode()) + " OK\n";
         stringBuilder.append(statusLine);
 
-        HTTPHeaderMap::const_iterator end = m_resourceResponse.httpHeaderFields().end();
-        for (HTTPHeaderMap::const_iterator it = m_resourceResponse.httpHeaderFields().begin(); it != end; ++it) {
+        // get copy of response headers, add/manipulate cache control headers to (maybe) prevent the flash player to cache in filesystem
+        HTTPHeaderMap responseHeaders = m_resourceResponse.httpHeaderFields();
+        responseHeaders.add("Expires", String("Thu, 01 Jan 1970 00:00:00 GMT, -1"));
+        responseHeaders.add("Cache-Control", String("no-cache, no-store, must-revalidate"));
+        responseHeaders.add("Pragma", String("no-cache"));
+
+        HTTPHeaderMap::const_iterator end = responseHeaders.end();
+        for (HTTPHeaderMap::const_iterator it = responseHeaders.begin(); it != end; ++it) {
             stringBuilder.append(it->key);
             stringBuilder.append(separator);
             stringBuilder.append(it->value);
diff -Nbaur qt/qtwebkit/Source/WebCore/plugins/mac/PluginViewMac.mm qt.new/qtwebkit/Source/WebCore/plugins/mac/PluginViewMac.mm
--- qt/qtwebkit/Source/WebCore/plugins/mac/PluginViewMac.mm	2015-12-17 16:24:04.000000000 +0100
+++ qt.new/qtwebkit/Source/WebCore/plugins/mac/PluginViewMac.mm	2015-12-17 16:26:56.000000000 +0100
@@ -77,6 +77,7 @@
 
 #if PLATFORM(QT)
 #include <QPainter>
+#include <QKeyEvent>
 #endif
 
 using namespace WTF;
@@ -282,8 +283,9 @@
 
     // The context is set through the draw event.
     ASSERT(!m_npCgContext.context && !m_npCgContext.window);
-    m_npWindow.window = (void*)&m_npCgContext;
+
     m_npWindow.type = NPWindowTypeDrawable;
+    m_npWindow.window = (void*)&m_npCgContext;
 
     m_npWindow.x = m_windowRect.x();
     m_npWindow.y = m_windowRect.y();
@@ -454,75 +456,39 @@
     if (!m_isStarted)
         return;
     
+    NPCocoaEvent cocoaEvent;
     NPCocoaEventType eventType;
-    int32_t buttonNumber = 0;
-    int32_t clickCount = 0;
-    NSEvent *currentEvent = [NSApp currentEvent];
 
-    NSEventType type = [currentEvent type];
+    initializeNPCocoaEvent(&cocoaEvent);
 
-    switch (type) {
-        case NSLeftMouseDown:
-        case NSRightMouseDown:
-        case NSOtherMouseDown:
-            buttonNumber = [currentEvent buttonNumber];
-            clickCount = [currentEvent clickCount];
+	if (event->type() == eventNames().mousedownEvent) {
             eventType = NPCocoaEventMouseDown;
-            // The plugin needs focus to receive keyboard events
+        // Give focus to the plugin on click
             if (Page* page = m_parentFrame->page())
-                page->focusController()->setFocusedFrame(m_parentFrame);
-            m_parentFrame->document()->setFocusedElement(m_element);
-            break;
+	        page->focusController()->setActive(true);
 
-        case NSLeftMouseUp:
-        case NSRightMouseUp:
-        case NSOtherMouseUp:
-            buttonNumber = [currentEvent buttonNumber];
-            clickCount = [currentEvent clickCount];
-            eventType = NPCocoaEventMouseUp;
-            break;
+	    focusPluginElement();
 
-        case NSMouseMoved:
+    } else if (event->type() == eventNames().mouseupEvent) {
+        eventType = NPCocoaEventMouseUp;
+    } else if (event->type() == eventNames().mousemoveEvent) {
             eventType = NPCocoaEventMouseMoved;
-            break;
-
-        case NSLeftMouseDragged:
-        case NSRightMouseDragged:
-        case NSOtherMouseDragged:
-            buttonNumber = [currentEvent buttonNumber];
-            eventType = NPCocoaEventMouseDragged;
-            break;
-
-        case NSMouseEntered:
+    } else if (event->type() == eventNames().mouseoverEvent) {
             eventType = NPCocoaEventMouseEntered;
-            break;
-
-        case NSMouseExited:
+    } else if (event->type() == eventNames().mouseoutEvent) {
             eventType = NPCocoaEventMouseExited;
-        default:
+    } else {
             return;
     }
 
-    NPCocoaEvent cocoaEvent;
-    initializeNPCocoaEvent(&cocoaEvent);
-
-    cocoaEvent.type = eventType;
-    if (!(NPCocoaEventMouseEntered == eventType || NPCocoaEventMouseExited == eventType)) {
-        cocoaEvent.data.mouse.buttonNumber = buttonNumber;
-        cocoaEvent.data.mouse.clickCount = clickCount;
-    }
-
     cocoaEvent.data.mouse.pluginX = event->layerX() - m_npWindow.x + m_windowRect.x() - m_element->offsetLeft();
     cocoaEvent.data.mouse.pluginY = event->layerY() - m_npWindow.y + m_windowRect.y() - m_element->offsetTop();
-    cocoaEvent.data.mouse.deltaX = [currentEvent deltaX];
-    cocoaEvent.data.mouse.deltaY = [currentEvent deltaY];
-    cocoaEvent.data.mouse.deltaZ = [currentEvent deltaZ];
     cocoaEvent.data.mouse.modifierFlags = getModifiers(event);
 
     int16_t response = dispatchNPCocoaEvent(cocoaEvent);
     if(response == kNPEventNotHandled) {
-        LOG(Events, "PluginView::handleMouseEvent(): Mouse event type %d at %d,%d not accepted", cocoaEvent.type,
-            cocoaEvent.data.mouse.pluginX, cocoaEvent.data.mouse.pluginY);
+        LOG(Events, "PluginView::handleMouseEvent(): Mouse event type %d at %f,%f,%f not accepted", cocoaEvent.type,
+            cocoaEvent.data.mouse.deltaX, cocoaEvent.data.mouse.deltaY, cocoaEvent.data.mouse.deltaZ);
     }
 
     // Safari policy is to return true for all mouse events, because some plugins
@@ -530,6 +496,176 @@
     event->setDefaultHandled();
 }
     
+static const int kUsVkeyToKeysym[256] = {
+	// 0x00 - 0x03
+	-1, -1, -1, -1,
+	// 0x04 - 0x07
+	-1, -1, -1, -1,
+	// 0x08 - 0x0b
+	-1, -1, -1, -1,
+	// 0x0c - 0x0f
+	-1, -1, -1, -1,
+	// 0x10 - 0x13
+	-1, -1, -1, -1,
+	// 0x14 - 0x17
+	-1, -1, -1, -1,
+	// 0x18 - 0x1b
+	-1, -1, -1, -1,
+	// 0x1c - 0x1f
+	-1, -1, -1, -1,
+	// 0x20 - 0x23
+	-1, -1, -1, -1,
+	// 0x24 - 0x27
+	-1, -1, -1, -1,
+	// 0x28 - 0x2b
+	-1, -1, -1, -1,
+	// 0x2c - 0x2f
+	-1, -1, -1, -1,
+	// 0x30 - 0x33
+	kVK_ANSI_0, kVK_ANSI_1, kVK_ANSI_2, kVK_ANSI_3,
+	// 0x34 - 0x37
+	kVK_ANSI_4, kVK_ANSI_5, kVK_ANSI_6, kVK_ANSI_7,
+	// 0x38 - 0x3b
+	kVK_ANSI_8, kVK_ANSI_9, -1, -1,
+	// 0x3c - 0x3f
+	-1, -1, -1, -1,
+	// 0x40 - 0x43
+	-1, kVK_ANSI_A, kVK_ANSI_B, kVK_ANSI_C,
+	// 0x44 - 0x47
+	kVK_ANSI_D, kVK_ANSI_E, kVK_ANSI_F, kVK_ANSI_G,
+	// 0x48 - 0x4b
+	kVK_ANSI_H, kVK_ANSI_I, kVK_ANSI_J, kVK_ANSI_K,
+	// 0x4c - 0x4f
+	kVK_ANSI_L, kVK_ANSI_M, kVK_ANSI_N, kVK_ANSI_O,
+	// 0x50 - 0x53
+	kVK_ANSI_P, kVK_ANSI_Q, kVK_ANSI_R, kVK_ANSI_S,
+	// 0x54 - 0x57
+	kVK_ANSI_T, kVK_ANSI_U, kVK_ANSI_V, kVK_ANSI_W,
+	// 0x58 - 0x5b
+	kVK_ANSI_X, kVK_ANSI_Y, kVK_ANSI_Z, -1,
+	// 0x5c - 0x5f
+	-1, -1, -1, -1,
+	// 0x60 - 0x63
+	kVK_ANSI_Keypad0, kVK_ANSI_Keypad1, kVK_ANSI_Keypad2, kVK_ANSI_Keypad3,
+	// 0x64 - 0x67
+	kVK_ANSI_Keypad4, kVK_ANSI_Keypad5, kVK_ANSI_Keypad6, kVK_ANSI_Keypad7,
+	// 0x68 - 0x6b
+	kVK_ANSI_Keypad8, kVK_ANSI_Keypad9, kVK_ANSI_KeypadMultiply, kVK_ANSI_KeypadPlus,
+	// 0x6c - 0x6f
+	-1, kVK_ANSI_KeypadMinus, kVK_ANSI_KeypadDecimal, kVK_ANSI_KeypadDivide,
+	// 0x70 - 0x73
+  	-1, -1, -1, -1,
+  	// 0x74 - 0x77
+	-1, -1, -1, -1,
+	// 0x78 - 0x7b
+	-1, -1, -1, -1,
+	// 0x7c - 0x7f
+	-1, -1, -1, -1,
+	// 0x80 - 0x83
+	-1, -1, -1, -1,
+	// 0x84 - 0x87
+	-1, -1, -1, -1,
+	// 0x88 - 0x8b
+	-1, -1, -1, -1,
+	// 0x8c - 0x8f
+	-1, -1, -1, -1,
+	// 0x90 - 0x93
+  	-1, -1, -1, -1,
+	// 0x94 - 0x97
+	-1, -1, -1, -1,
+	// 0x98 - 0x9b
+	-1, -1, -1, -1,
+	// 0x9c - 0x9f
+	-1, -1, -1, -1,
+	// 0xa0 - 0xa3
+	-1, -1, -1, -1,
+	// 0xa4 - 0xa7
+	-1, -1, -1, -1,
+	// 0xa8 - 0xab
+	-1, -1, -1, -1,
+	// 0xac - 0xaf
+	-1, -1, -1, -1,
+	// 0xb0 - 0xb3
+	-1, -1, -1, -1,
+	// 0xb4 - 0xb7
+	-1, -1, -1, -1,
+	// 0xb8 - 0xbb
+	-1, -1, kVK_ANSI_Semicolon, kVK_ANSI_KeypadPlus,
+	// 0xbc - 0xbf
+	kVK_ANSI_Comma, kVK_ANSI_KeypadMinus, kVK_ANSI_Period, kVK_ANSI_Slash,
+	// 0xc0 - 0xc3
+	kVK_ANSI_Grave, -1, -1, -1,
+	// 0xc4 - 0xc7
+	-1, -1, -1, -1,
+	// 0xc8 - 0xcb
+	-1, -1, -1, -1,
+	// 0xcc - 0xcf
+	-1, -1, -1, -1,
+	// 0xd0 - 0xd3
+	-1, -1, -1, -1,
+	// 0xd4 - 0xd7
+	-1, -1, -1, -1,
+	// 0xd8 - 0xdb
+	-1, -1, -1, kVK_ANSI_LeftBracket,
+	// 0xdc - 0xdf
+	kVK_ANSI_Backslash, kVK_ANSI_RightBracket, kVK_ANSI_Quote, -1,
+	// 0xe0 - 0xe3
+  	-1, -1, -1, -1,
+	// 0xe4 - 0xe7
+	-1, -1, -1, -1,
+	// 0xe8 - 0xeb
+	-1, -1, -1, -1,
+	// 0xec - 0xef
+	-1, -1, -1, -1,
+	// 0xf0 - 0xf3
+	-1, -1, -1, -1,
+	// 0xf4 - 0xf7
+	-1, -1, -1, -1,
+	// 0xf8 - 0xfb
+	-1, -1, -1, -1,
+	// 0xfc - 0xff
+	-1, -1, -1, -1
+};
+
+static int translateKeyCodeQt(QKeyEvent *event)
+{
+	int ksym = -1;
+	switch(event->key()) {
+	case Qt::Key_Space		: ksym = kVK_Space; break;
+	case Qt::Key_Delete		: ksym = kVK_ForwardDelete; break;
+	case Qt::Key_Backspace	: ksym = kVK_Delete; break;
+	case Qt::Key_Tab		: ksym = kVK_Tab; break;
+	case Qt::Key_Enter:
+	case Qt::Key_Return		: ksym = kVK_Return; break;
+	case Qt::Key_Escape		: ksym = kVK_Escape; break;
+	case Qt::Key_Home		: ksym = kVK_Home; break;
+	case Qt::Key_End		: ksym = kVK_End; break;
+	case Qt::Key_PageUp		: ksym = kVK_PageUp; break;
+	case Qt::Key_PageDown	: ksym = kVK_PageDown; break;
+	case Qt::Key_Left		: ksym = kVK_LeftArrow; break;
+	case Qt::Key_Right		: ksym = kVK_RightArrow; break;
+	case Qt::Key_Up			: ksym = kVK_UpArrow; break;
+	case Qt::Key_Down		: ksym = kVK_DownArrow; break;
+	case Qt::Key_F1			: ksym = kVK_F1; break;
+	case Qt::Key_F2			: ksym = kVK_F2; break;
+	case Qt::Key_F3			: ksym = kVK_F3; break;
+	case Qt::Key_F4			: ksym = kVK_F4; break;
+	case Qt::Key_F5			: ksym = kVK_F5; break;
+	case Qt::Key_F6			: ksym = kVK_F6; break;
+	case Qt::Key_F7			: ksym = kVK_F7; break;
+	case Qt::Key_F8			: ksym = kVK_F8; break;
+	case Qt::Key_F9			: ksym = kVK_F9; break;
+	case Qt::Key_F10		: ksym = kVK_F10; break;
+	case Qt::Key_F11		: ksym = kVK_F11; break;
+	case Qt::Key_F12		: ksym = kVK_F12; break;
+	default:
+		if(event->key() < Qt::Key_Escape)
+			ksym = kUsVkeyToKeysym[(int)event->key()];
+		break;
+	}
+	return ksym;
+}
+
 void PluginView::handleKeyboardEvent(KeyboardEvent* event)
 {
     if (!m_isStarted)
@@ -539,65 +675,73 @@
     LOG(Plugins, "PV::hKE(): KE.keyCode: 0x%02X, KE.charCode: %d",
         event->keyCode(), event->charCode());
 
-    NSEvent *currentEvent = [NSApp currentEvent];
+    NPCocoaEvent cocoaEvent;
     NPCocoaEventType eventType;
-    NSEventType type = [currentEvent type];
 
-    switch (type) {
-        case NSKeyDown:
+    initializeNPCocoaEvent(&cocoaEvent);
+
+    if (event->type() == eventNames().keydownEvent) {
+        return;
+    } else if (event->type() == eventNames().keypressEvent) {
             eventType = NPCocoaEventKeyDown;
             m_keyDownSent = true;
-            break;
-        case NSKeyUp:
+    } else if (event->type() == eventNames().keyupEvent) {
             if (m_disregardKeyUpCounter > 0) {
                 m_disregardKeyUpCounter--;
                 event->setDefaultHandled();
                 return;
             }
             eventType = NPCocoaEventKeyUp;
-            break;
-        case NSFlagsChanged:
-            eventType = NPCocoaEventFlagsChanged;
-            break;
-        default:
+    } else {
             return;
     }
 
-    NPCocoaEvent cocoaEvent;
-    initializeNPCocoaEvent(&cocoaEvent);
+	const PlatformKeyboardEvent* platformEvent = event->keyEvent();
+	int keyCode = platformEvent->nativeVirtualKeyCode();
+	if (!keyCode)
+		keyCode = translateKeyCodeQt(platformEvent->qtEvent());
+
+	if(keyCode < 0) {
+		event->setDefaultHandled();
+		return;
+	}
+
+	WTF::RetainPtr<CFStringRef> cfText = platformEvent->text().createCFString();
+	WTF::RetainPtr<CFStringRef> cfUnmodifiedText = platformEvent->unmodifiedText().createCFString();
+	NSString *characters = (NSString*) cfText.get();
+	NSString *unmodifiedCharacters = (NSString*) cfUnmodifiedText.get();
+
     cocoaEvent.type = eventType;
-    if (eventType != NPCocoaEventFlagsChanged) {
-        NSString *characters = [currentEvent characters];
-        NSString *charactersIgnoringModifiers = [currentEvent charactersIgnoringModifiers];
         cocoaEvent.data.key.characters = reinterpret_cast<NPNSString*>(characters);
-        cocoaEvent.data.key.charactersIgnoringModifiers = reinterpret_cast<NPNSString*>(charactersIgnoringModifiers);
-        cocoaEvent.data.key.isARepeat = [currentEvent isARepeat];
-        cocoaEvent.data.key.keyCode = [currentEvent keyCode];
+    cocoaEvent.data.key.charactersIgnoringModifiers = reinterpret_cast<NPNSString*>(unmodifiedCharacters);
+    cocoaEvent.data.key.isARepeat = platformEvent->isAutoRepeat();
+    cocoaEvent.data.key.keyCode = keyCode;
         cocoaEvent.data.key.modifierFlags = getModifiers(event);
-    }
 
     int16_t response = dispatchNPCocoaEvent(cocoaEvent);
     if(response == kNPEventNotHandled) {
-        LOG(Events, "PluginView::handleKeyboardEvent(): Keyboard event type %d not accepted", cocoaEvent.type);
+        LOG(Events, "PluginView::handleKeyboardEvent(1): Keyboard event type %d not accepted", cocoaEvent.type);
     } else if (response == kNPEventStartIME) {
         // increment counter and resend as a text input
         m_disregardKeyUpCounter++;
         NPCocoaEvent textEvent;
         initializeNPCocoaEvent(&textEvent);
         textEvent.type = NPCocoaEventTextInput;
-        textEvent.data.text.text = reinterpret_cast<NPNSString*>([currentEvent characters]);
+        textEvent.data.text.text = reinterpret_cast<NPNSString*>(characters);
         response = dispatchNPCocoaEvent(textEvent);
-        if(response == kNPEventNotHandled)
+        if(response == kNPEventNotHandled) {
             LOG(Events, "PluginView::handleKeyboardEvent(): Keyboard event type %d not accepted", cocoaEvent.type);
     }
+    }
 
     // All keyboard events need to be handled to prevent them falling
     // through to the page, unless they are Meta key events, in which
     // case they are, unless they are Cmd+a. From WebKit2, possibly
     // not the most elegant piece of key handling code.....
     if (event->metaKey()) {
-        if (cocoaEvent.data.key.keyCode == 0)
+        if (cocoaEvent.data.key.keyCode == 0) {
             event->setDefaultHandled();
+        }    
     } else {
         // else ignore, it's a Meta Key event for the browser.
         event->setDefaultHandled();
diff -Nbaur qt/qtwebkit/Source/WebCore/plugins/npapi.h qt.new/qtwebkit/Source/WebCore/plugins/npapi.h
--- qt/qtwebkit/Source/WebCore/plugins/npapi.h	2015-12-17 16:24:04.000000000 +0100
+++ qt.new/qtwebkit/Source/WebCore/plugins/npapi.h	2015-12-17 16:26:56.000000000 +0100
@@ -84,10 +84,8 @@
 #if defined(XP_MACOSX)
 #include <ApplicationServices/ApplicationServices.h>
 #include <OpenGL/OpenGL.h>
-#ifndef NP_NO_CARBON
 #include <Carbon/Carbon.h>
 #endif
-#endif
 
 #if defined(XP_UNIX)
 #include <stdio.h>
diff -Nbaur qt/qtwebkit/Source/WebCore/plugins/qt/PluginViewQt.cpp qt.new/qtwebkit/Source/WebCore/plugins/qt/PluginViewQt.cpp
--- qt/qtwebkit/Source/WebCore/plugins/qt/PluginViewQt.cpp	2015-12-17 16:24:04.000000000 +0100
+++ qt.new/qtwebkit/Source/WebCore/plugins/qt/PluginViewQt.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -312,6 +312,64 @@
     setSharedXEventFields(xEvent, client);
 }
 
+static unsigned int translateModifiers(const PlatformKeyboardEvent *event)
+{
+    unsigned int state = 0;
+    if (event->ctrlKey())
+        state |= ControlMask;
+    if (event->shiftKey())
+        state |= ShiftMask;
+    if (event->altKey())
+        state |= Mod1Mask;
+    if (event->metaKey())
+        state |= Mod4Mask;
+    return state;
+	
+}
+
+static unsigned int translateKeyCodeQt(QKeyEvent *event)
+{
+    ASSERT(event);
+
+    KeySym ksym;
+    QString keyText;
+	switch(event->key()) {
+	case Qt::Key_Space		: ksym = XK_space; break;
+	case Qt::Key_Backspace	: ksym = XK_BackSpace; break;
+	case Qt::Key_Tab		: ksym = XK_Tab; break;
+	case Qt::Key_Enter		:
+	case Qt::Key_Return		: ksym = XK_Return; break;
+	case Qt::Key_Escape		: ksym = XK_Escape; break;
+	case Qt::Key_Delete		: ksym = XK_Delete; break;
+	case Qt::Key_Home		: ksym = XK_Home; break;
+	case Qt::Key_End		: ksym = XK_End; break;
+	case Qt::Key_PageUp		: ksym = XK_Page_Up; break;
+	case Qt::Key_PageDown	: ksym = XK_Page_Down; break;
+	case Qt::Key_Insert		: ksym = XK_Insert; break;
+	case Qt::Key_Left		: ksym = XK_Left; break;
+	case Qt::Key_Right		: ksym = XK_Right; break;
+	case Qt::Key_Up			: ksym = XK_Up; break;
+	case Qt::Key_Down		: ksym = XK_Down; break;
+	case Qt::Key_F1			: ksym = XK_F1; break;
+	case Qt::Key_F2			: ksym = XK_F2; break;
+	case Qt::Key_F3			: ksym = XK_F3; break;
+	case Qt::Key_F4			: ksym = XK_F4; break;
+	case Qt::Key_F5			: ksym = XK_F5; break;
+	case Qt::Key_F6			: ksym = XK_F6; break;
+	case Qt::Key_F7			: ksym = XK_F7; break;
+	case Qt::Key_F8			: ksym = XK_F8; break;
+	case Qt::Key_F9			: ksym = XK_F9; break;
+	case Qt::Key_F10		: ksym = XK_F10; break;
+	case Qt::Key_F11		: ksym = XK_F11; break;
+	case Qt::Key_F12		: ksym = XK_F12; break;
+	default:
+		keyText = event->text().left(1);
+		ksym = XStringToKeysym(keyText.toUtf8().constData());
+		break;
+	}
+	return XKeysymToKeycode(x11Display(), ksym);
+}
+
 void PluginView::setXKeyEventSpecificFields(XEvent* xEvent, KeyboardEvent* event)
 {
     const PlatformKeyboardEvent* keyEvent = event->keyEvent();
@@ -323,15 +381,22 @@
     xEvent->xkey.state = keyEvent->nativeModifiers();
     xEvent->xkey.keycode = keyEvent->nativeScanCode();
 
+    // We may not have a nativeModifiers() if the key event is from DRT's eventsender. In that
+    // case fetch the XEvent's modifiers from the event's modifiers. The only
+    // place this modifiers will be used is in webkit_test_plugin_handle_event().
+    // For now always try to get from event's modifiers if no native modifiers are available.
+    // FIXME: Create Qt API so that we can set the appropriate modifiers in DRT EventSender instead.
+    if (!xEvent->xkey.state) {
+        xEvent->xkey.state = translateModifiers(keyEvent);
+    }
+	
     // We may not have a nativeScanCode() if the key event is from DRT's eventsender. In that
     // case fetch the XEvent's keycode from the event's text. The only
     // place this keycode will be used is in webkit_test_plugin_handle_event().
+    // For now always try to get from event's text if no native scan code is available.
     // FIXME: Create Qt API so that we can set the appropriate keycode in DRT EventSender instead.
-    if (s_isRunningUnderDRT && !xEvent->xkey.keycode) {
-        QKeyEvent* qKeyEvent = keyEvent->qtEvent();
-        ASSERT(qKeyEvent);
-        QString keyText = qKeyEvent->text().left(1);
-        xEvent->xkey.keycode = XKeysymToKeycode(x11Display(), XStringToKeysym(keyText.toUtf8().constData()));
+    if (!xEvent->xkey.keycode) {
+        xEvent->xkey.keycode = translateKeyCodeQt(keyEvent->qtEvent());
     }
 
     xEvent->xkey.same_screen = true;
diff -Nbaur qt/qtwebkit/Source/WebKit/WebKit1.pro qt.new/qtwebkit/Source/WebKit/WebKit1.pro
--- qt/qtwebkit/Source/WebKit/WebKit1.pro	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/WebKit1.pro	2015-12-17 16:26:56.000000000 +0100
@@ -49,6 +49,7 @@
     $$PWD/qt/WebCoreSupport/QtPrintContext.cpp \
     $$PWD/qt/WebCoreSupport/QWebFrameAdapter.cpp \
     $$PWD/qt/WebCoreSupport/QWebPageAdapter.cpp \
+    $$PWD/qt/WebCoreSupport/QWebPopupAdapter.cpp \
     $$PWD/qt/WebCoreSupport/SearchPopupMenuQt.cpp \
     $$PWD/qt/WebCoreSupport/TextCheckerClientQt.cpp \
     $$PWD/qt/WebCoreSupport/TextureMapperLayerClientQt.cpp \
@@ -87,6 +88,7 @@
     $$PWD/qt/WebCoreSupport/QtPrintContext.h \
     $$PWD/qt/WebCoreSupport/QWebFrameAdapter.h \
     $$PWD/qt/WebCoreSupport/QWebPageAdapter.h \
+    $$PWD/qt/WebCoreSupport/QWebPopupAdapter.h \
     $$PWD/qt/WebCoreSupport/SearchPopupMenuQt.h \
     $$PWD/qt/WebCoreSupport/TextCheckerClientQt.h \
     $$PWD/qt/WebCoreSupport/TextureMapperLayerClientQt.h \
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/ChromeClientQt.cpp qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/ChromeClientQt.cpp
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/ChromeClientQt.cpp	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/ChromeClientQt.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -613,6 +613,9 @@
 {
 #ifndef QT_NO_CURSOR
     QWebPageClient* pageClient = platformPageClient();
+    
+    emit m_webPage->cursorChanged(*cursor.platformCursor());
+    
     if (!pageClient)
         return;
     pageClient->setCursor(*cursor.platformCursor());
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/DragClientQt.cpp qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/DragClientQt.cpp
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/DragClientQt.cpp	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/DragClientQt.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -38,6 +38,9 @@
 #include <QDrag>
 #include <QMimeData>
 #include <QWebPageClient.h>
+#include <QWebPageAdapter.h>
+
+#include <QtWidgets/qapplication.h>
 
 namespace WebCore {
 
@@ -96,16 +99,20 @@
     QMimeData* clipboardData = clipboard->pasteboard().clipboardData();
     clipboard->pasteboard().invalidateWritableData();
     PlatformPageClient pageClient = m_chromeClient->platformPageClient();
-    QObject* view = pageClient ? pageClient->ownerWidget() : 0;
+    QObject* view = pageClient ? pageClient->ownerWidget() : reinterpret_cast<QObject*>(QApplication::desktop());
     if (view) {
         QDrag* drag = new QDrag(view);
+        
+        view->setProperty("__originator", QVariant::fromValue<QObject*>(QWebPageAdapter::kit(frame->page())->handle()));
         if (dragImage) {
             drag->setPixmap(*dragImage);
             drag->setHotSpot(IntPoint(eventPos - dragImageOrigin));
         } else if (clipboardData && clipboardData->hasImage())
             drag->setPixmap(qvariant_cast<QPixmap>(clipboardData->imageData()));
-        DragOperation dragOperationMask = clipboard->sourceOperation();
+
         drag->setMimeData(clipboardData);
+
+        DragOperation dragOperationMask = clipboard->sourceOperation();
         Qt::DropAction actualDropAction = drag->exec(dragOperationsToDropActions(dragOperationMask));
 
         // Send dragEnd event
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/FrameLoaderClientQt.cpp qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/FrameLoaderClientQt.cpp
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/FrameLoaderClientQt.cpp	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/FrameLoaderClientQt.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -1548,6 +1548,21 @@
                 values[wmodeIndex] = "opaque";
         }
 
+        /* For the time being we disable the ability to run a flash plugin in fullscreen mode */
+        size_t allowfullscreenIndex = params.find("allowfullscreen");
+        if(allowfullscreenIndex == WTF::notFound) {
+         	params.append("allowfullscreen");
+           	values.append("false");
+        } else if(equalIgnoringCase(values[allowfullscreenIndex], "true"))
+           	values[allowfullscreenIndex] = "false";
+
+        size_t allowfullscreeninteractiveIndex = params.find("allowfullscreeninteractive");
+        if(allowfullscreeninteractiveIndex == WTF::notFound) {
+           	params.append("allowfullscreeninteractive");
+           	values.append("false");
+        } else if(equalIgnoringCase(values[allowfullscreeninteractiveIndex], "true"))
+           	values[allowfullscreeninteractiveIndex] = "false";
+           	
         RefPtr<PluginView> pluginView = PluginView::create(m_frame, pluginSize, element, url,
             params, values, mimeType, loadManually);
         return pluginView;
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/InspectorServerQt.cpp qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/InspectorServerQt.cpp
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/InspectorServerQt.cpp	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/InspectorServerQt.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -279,6 +279,8 @@
 int InspectorServerRequestHandlerQt::webSocketSend(const char* data, size_t length)
 {
     Q_ASSERT(m_tcpConnection);
+    if(!m_tcpConnection)
+    	return -1;
     m_tcpConnection->putChar(0x81);
     if (length <= 125)
         m_tcpConnection->putChar(static_cast<uint8_t>(length));
@@ -310,6 +312,8 @@
 void InspectorServerRequestHandlerQt::webSocketReadyRead()
 {
     Q_ASSERT(m_tcpConnection);
+    if (!m_tcpConnection)
+    	return;
     if (!m_tcpConnection->bytesAvailable())
         return;
     QByteArray content = m_tcpConnection->read(m_tcpConnection->bytesAvailable());
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/PopupMenuQt.cpp qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/PopupMenuQt.cpp
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/PopupMenuQt.cpp	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/PopupMenuQt.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -30,6 +30,7 @@
 #include "FrameView.h"
 #include "PopupMenuClient.h"
 #include "qwebkitplatformplugin.h"
+#include "QWebPopupAdapter.h"
 
 class SelectData : public QWebSelectData {
 public:
@@ -99,10 +100,18 @@
         connect(m_popup.get(), SIGNAL(selectItem(int, bool, bool)), this, SLOT(selectItem(int, bool, bool)));
     }
 
+    if (QWebPopupAdapter *fallback = qobject_cast<QWebPopupAdapter*>(m_popup.get())) {
+        QRect geometry(rect);
+        geometry.moveTopLeft(view->contentsToWindow(rect.location()));
+        fallback->setGeometry(geometry);
+        fallback->setPage(m_chromeClient->m_webPage);
+        fallback->setFont(m_popupClient->menuStyle().font().syntheticFont());
+    } else {
     QRect geometry(rect);
     geometry.moveTopLeft(view->contentsToWindow(rect.location()));
     m_popup->setGeometry(geometry);
     m_popup->setFont(m_popupClient->menuStyle().font().syntheticFont());
+    }
 
     m_selectData = adoptPtr(new SelectData(m_popupClient));
     m_popup->show(*m_selectData.get());
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -554,6 +554,60 @@
 #endif
 }
 
+void QWebFrameAdapter::renderAbsoluteCoords(QPainter* painter, int layers, const QRegion& clip)
+{
+    GraphicsContext context(painter);
+    if (context.paintingDisabled() && !context.updatingControlTints())
+        return;
+
+    if (!frame->view() || !frame->contentRenderer())
+        return;
+
+    QVector<QRect> vector = clip.rects();
+    if (vector.isEmpty())
+        return;
+
+    WebCore::FrameView* view = frame->view();
+    view->updateLayoutAndStyleIfNeededRecursive();
+
+    if (layers & ContentsLayer) {
+    	for(int i=0;i < vector.size();i++) {
+            int x = view->x();
+            int y = view->y();
+    		const QRect& clipRect = vector.at(i);
+
+    		QRect cRect = QRect(QPoint(0, 0), clipRect.size());
+    		QRect rect = clipRect.intersected(QRect(QPoint(0, 0), view->contentsSize()));
+
+    		context.save();
+            painter->setClipRect(cRect, Qt::IntersectClip);
+
+            int scrollX = clipRect.x();
+            int scrollY = clipRect.y();
+
+            context.translate(x, y);
+            rect.translate(-x, -y);
+            context.translate(-scrollX, -scrollY);
+            context.clip(rect);
+
+            view->paintContents(&context, rect);
+
+            context.restore();
+    	}
+#if USE(ACCELERATED_COMPOSITING)
+        renderCompositedLayers(&context, IntRect(clip.boundingRect()));
+#endif
+    }
+    renderFrameExtras(&context, layers, clip);
+#if ENABLE(INSPECTOR)
+    if (frame->page()->inspectorController()->highlightedNode()) {
+        context.save();
+        frame->page()->inspectorController()->drawHighlight(context);
+        context.restore();
+    }
+#endif
+}
+
 void QWebFrameAdapter::renderFrameExtras(WebCore::GraphicsContext* context, int layers, const QRegion& clip)
 {
     if (!(layers & (PanIconLayer | ScrollBarLayer)))
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.h qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.h
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.h	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.h	2015-12-17 16:26:56.000000000 +0100
@@ -177,6 +177,7 @@
     QString uniqueName() const;
 
     void renderRelativeCoords(QPainter*, int layers, const QRegion& clip);
+    void renderAbsoluteCoords(QPainter*, int layers, const QRegion& clip);
     void renderFrameExtras(WebCore::GraphicsContext*, int layers, const QRegion& clip);
 #if USE(ACCELERATED_COMPOSITING)
     void renderCompositedLayers(WebCore::GraphicsContext*, const WebCore::IntRect& clip);
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPageAdapter.h qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPageAdapter.h
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPageAdapter.h	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPageAdapter.h	2015-12-17 16:26:56.000000000 +0100
@@ -175,6 +175,7 @@
     virtual bool javaScriptPrompt(QWebFrameAdapter*, const QString& msg, const QString& defaultValue, QString* result) = 0;
     virtual bool shouldInterruptJavaScript() = 0;
     virtual void printRequested(QWebFrameAdapter*) = 0;
+    virtual void cursorChanged(const QCursor &cursor) = 0;
     virtual void databaseQuotaExceeded(QWebFrameAdapter*, const QString& databaseName) = 0;
     virtual void applicationCacheQuotaExceeded(QWebSecurityOrigin*, quint64 defaultOriginQuota, quint64 totalSpaceNeeded) = 0;
     virtual void setToolTip(const QString&) = 0;
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPopupAdapter.cpp qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPopupAdapter.cpp
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPopupAdapter.cpp	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPopupAdapter.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,10 @@
+#include "config.h"
+#include "QWebPopupAdapter.h"
+
+QWebPopupAdapter::QWebPopupAdapter()
+{
+}
+
+QWebPopupAdapter::~QWebPopupAdapter()
+{
+}
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPopupAdapter.h qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPopupAdapter.h
--- qt/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPopupAdapter.h	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WebCoreSupport/QWebPopupAdapter.h	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef QWebPopupAdapter_h
+#define QWebPopupAdapter_h
+
+#include "PlatformExportMacros.h"
+#include "qwebkitplatformplugin.h"
+
+#include <QRect>
+#include <QFont>
+
+class QWebPageAdapter;
+
+class WEBKIT_EXPORTDATA QWebPopupAdapter : public QWebSelectMethod
+{
+	Q_OBJECT
+public:
+	QWebPopupAdapter();
+	virtual ~QWebPopupAdapter();
+
+	virtual QObject* handle() = 0;
+	
+    virtual void setGeometry(const QRect& rect) OVERRIDE { m_geometry = rect; }
+    virtual const QRect& geometry() const { return m_geometry; }
+
+    virtual void setFont(const QFont& font) OVERRIDE { m_font = font; }
+    virtual const QFont& font() const { return m_font; }
+
+    virtual void setPage(QWebPageAdapter *page) { m_webPage = page; }
+    virtual QWebPageAdapter* page() const { return m_webPage; }
+    
+protected:
+    QRect m_geometry;
+    QFont m_font;
+    
+    QWebPageAdapter *m_webPage;
+};
+
+#endif // QWebPopupAdapter_h
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebframe.cpp qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebframe.cpp
--- qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebframe.cpp	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebframe.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -656,6 +656,14 @@
     render(painter, AllLayers, clip);
 }
 
+void QWebFrame::renderAbsolute(QPainter* painter, const QRegion& clip)
+{
+    if (!clip.isEmpty())
+        d->renderAbsoluteCoords(painter, AllLayers, clip);
+    else if (d->hasView())
+        d->renderAbsoluteCoords(painter, AllLayers, QRegion(d->frameRect()));
+}
+
 /*!
     \property QWebFrame::textSizeMultiplier
     \brief the scaling factor for all text in the frame
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebframe.h qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebframe.h
--- qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebframe.h	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebframe.h	2015-12-17 16:26:56.000000000 +0100
@@ -183,6 +183,8 @@
     void render(QPainter*, const QRegion& clip = QRegion());
     void render(QPainter*, RenderLayers layer, const QRegion& clip = QRegion());
 
+    void renderAbsolute(QPainter*, const QRegion& clip);
+	
     void setTextSizeMultiplier(qreal factor);
     qreal textSizeMultiplier() const;
 
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage.cpp qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage.cpp
--- qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage.cpp	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -316,6 +316,11 @@
     emit q->printRequested(QWebFramePrivate::kit(frame));
 }
 
+void QWebPagePrivate::cursorChanged(const QCursor &cursor)
+{
+	emit q->cursorChanged(cursor);
+}
+
 void QWebPagePrivate::databaseQuotaExceeded(QWebFrameAdapter* frame, const QString& databaseName)
 {
     emit q->databaseQuotaExceeded(QWebFramePrivate::kit(frame), databaseName);
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage.h qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage.h
--- qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage.h	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage.h	2015-12-17 16:26:56.000000000 +0100
@@ -266,7 +266,7 @@
 
 
     explicit QWebPage(QObject *parent = 0);
-    ~QWebPage();
+    virtual ~QWebPage();
 
     QWebFrame *mainFrame() const;
     QWebFrame *currentFrame() const;
@@ -415,6 +415,7 @@
 
     void microFocusChanged();
     void contentsChanged();
+    void cursorChanged(const QCursor &cursor);
     void databaseQuotaExceeded(QWebFrame* frame, QString databaseName);
     void applicationCacheQuotaExceeded(QWebSecurityOrigin* origin, quint64 defaultOriginQuota, quint64 totalSpaceNeeded);
 
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage_p.h qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage_p.h
--- qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage_p.h	2015-12-17 16:24:05.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpage_p.h	2015-12-17 16:26:56.000000000 +0100
@@ -92,6 +92,7 @@
 
     virtual bool shouldInterruptJavaScript() OVERRIDE;
     virtual void printRequested(QWebFrameAdapter*) OVERRIDE;
+    virtual void cursorChanged(const QCursor &cursor) OVERRIDE;
     virtual void databaseQuotaExceeded(QWebFrameAdapter*, const QString& databaseName) OVERRIDE;
     virtual void applicationCacheQuotaExceeded(QWebSecurityOrigin*, quint64 defaultOriginQuota, quint64 totalSpaceNeeded) OVERRIDE;
     virtual void setToolTip(const QString&) OVERRIDE;
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup.cpp qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup.cpp
--- qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup.cpp	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup.cpp	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,74 @@
+/*
+ * qwebpopup.cpp
+ *
+ *  Created on: Oct 24, 2012
+ *      Author: mike
+ */
+
+#include "config.h"
+#include "qwebpopup.h"
+#include "qwebpopup_p.h"
+
+QWebPopupPrivate::QWebPopupPrivate(QWebPopup *qq) : q(qq)
+{
+	connect(this, SIGNAL(destroyed(QObject*)), q, SIGNAL(destroyed(QObject*)), Qt::DirectConnection);
+}
+
+QWebPopupPrivate::~QWebPopupPrivate()
+{
+	q->deleteLater();
+}
+
+void QWebPopupPrivate::show(const QWebSelectData& data)
+{
+	q->show(data);
+}
+
+void QWebPopupPrivate::hide()
+{
+	q->hide();
+}
+
+QWebPopup::QWebPopup(QObject *parent)
+    : QObject(parent)
+    , d(new QWebPopupPrivate(this))
+    , m_content(NULL)
+{
+
+}
+
+QWebPopup::~QWebPopup()
+{
+
+}
+
+QWebPopupAdapter* QWebPopup::handle() const
+{
+	return d;
+}
+
+QObject* QWebPopup::page() const
+{
+	return d->page()->handle();
+}
+
+void QWebPopup::selectItem(int index, bool allowMultiplySelections, bool shift)
+{
+	emit d->selectItem(index, allowMultiplySelections, shift);
+}
+
+void QWebPopup::didHide()
+{
+	emit d->didHide();
+}
+
+const QRect& QWebPopup::geometry() const
+{
+	return d->geometry();
+}
+
+const QFont& QWebPopup::font() const
+{
+	return d->font();
+}
+
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup.h qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup.h
--- qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup.h	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup.h	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,52 @@
+/*
+ * qwebpopup.h
+ *
+ *  Created on: Oct 24, 2012
+ *      Author: mike
+ */
+
+#ifndef QWEBPOPUP_H_
+#define QWEBPOPUP_H_
+
+#include <QtWebKit/qwebkitglobal.h>
+#include <QtWebKit/qwebsettings.h>
+#include <QtWebKit/qwebkitplatformplugin.h>
+
+#include <QtGui/qfont.h>
+#include <QtCore/qrect.h>
+
+class QWebPage;
+class QWebPopupPrivate;
+class QWebPopupAdapter;
+
+class QWEBKITWIDGETS_EXPORT QWebPopup : public QObject
+{
+	Q_OBJECT
+
+public:
+	explicit QWebPopup(QObject *parent = 0);
+	virtual ~QWebPopup();
+
+    QObject* page() const;
+
+    const QRect& geometry() const;
+    const QFont& font() const;
+
+    void setContent(QObject *content) { m_content = content; }
+    QObject* content() const { return m_content; }
+
+	QWebPopupAdapter* handle() const;
+	
+    void selectItem(int index, bool allowMultiplySelections, bool shift);
+    void didHide();
+
+    virtual void show(const QWebSelectData& data) = 0;
+    virtual void hide() = 0;
+
+protected:
+	QWebPopupPrivate *d;
+	
+    QObject *m_content;
+};
+
+#endif /* QWEBPOPUP_H_ */
diff -Nbaur qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup_p.h qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup_p.h
--- qt/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup_p.h	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtwebkit/Source/WebKit/qt/WidgetApi/qwebpopup_p.h	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,23 @@
+#ifndef qwebpopup_p_h
+#define qwebpopup_p_h
+
+#include "QWebPopupAdapter.h"
+#include "QWebPageAdapter.h"
+
+#include "qwebpopup.h"
+
+class QWebPopupPrivate : public QWebPopupAdapter
+{
+public:
+	QWebPopupPrivate(QWebPopup *qq);
+	~QWebPopupPrivate();
+	
+    virtual QObject* handle() OVERRIDE { return q; }
+	
+    virtual void show(const QWebSelectData& data) OVERRIDE;
+    virtual void hide() OVERRIDE;
+
+	QWebPopup *q;
+};
+
+#endif // qwebpopup_p_h
diff -Nbaur qt/qtwebkit/Source/widgetsapi.pri qt.new/qtwebkit/Source/widgetsapi.pri
--- qt/qtwebkit/Source/widgetsapi.pri	2015-12-17 16:24:06.000000000 +0100
+++ qt.new/qtwebkit/Source/widgetsapi.pri	2015-12-17 16:26:56.000000000 +0100
@@ -113,6 +113,7 @@
     $$PWD/WebKit/qt/WidgetApi/qwebpage.cpp \
     $$PWD/WebKit/qt/WidgetApi/qwebview.cpp \
     $$PWD/WebKit/qt/WidgetApi/qwebinspector.cpp \
+    $$PWD/WebKit/qt/WidgetApi/qwebpopup.cpp \
     $$PWD/WebKit/qt/WidgetSupport/QtFallbackWebPopup.cpp \
     $$PWD/WebKit/qt/WidgetSupport/QtWebComboBox.cpp \
     $$PWD/WebKit/qt/WidgetSupport/QWebUndoCommand.cpp \
@@ -132,6 +133,8 @@
     $$PWD/WebKit/qt/WidgetApi/qwebview.h \
     $$PWD/WebKit/qt/WidgetApi/qwebinspector.h \
     $$PWD/WebKit/qt/WidgetApi/qwebinspector_p.h \
+    $$PWD/WebKit/qt/WidgetApi/qwebpopup.h \
+    $$PWD/WebKit/qt/WidgetApi/qwebpopup_p.h \
     $$PWD/WebKit/qt/WidgetSupport/InitWebKitQt.h \
     $$PWD/WebKit/qt/WidgetSupport/InspectorClientWebPage.h \
     $$PWD/WebKit/qt/WidgetSupport/QtFallbackWebPopup.h \
diff -Nbaur qt/qtwebkit/Tools/qmake/config.tests/gnuld/gnuld.exe.embed.manifest qt.new/qtwebkit/Tools/qmake/config.tests/gnuld/gnuld.exe.embed.manifest
--- qt/qtwebkit/Tools/qmake/config.tests/gnuld/gnuld.exe.embed.manifest	1970-01-01 01:00:00.000000000 +0100
+++ qt.new/qtwebkit/Tools/qmake/config.tests/gnuld/gnuld.exe.embed.manifest	2015-12-17 16:26:56.000000000 +0100
@@ -0,0 +1,15 @@
+<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
+<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
+  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
+    <security>
+      <requestedPrivileges>
+        <requestedExecutionLevel level='asInvoker' uiAccess='false' />
+      </requestedPrivileges>
+    </security>
+  </trustInfo>
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' publicKeyToken='6595b64144ccf1df' language='*' processorArchitecture='*' />
+    </dependentAssembly>
+  </dependency>
+</assembly>
diff -Nbaur qt/qtwebkit/Tools/qmake/mkspecs/features/features.pri qt.new/qtwebkit/Tools/qmake/mkspecs/features/features.pri
--- qt/qtwebkit/Tools/qmake/mkspecs/features/features.pri	2015-12-17 16:24:07.000000000 +0100
+++ qt.new/qtwebkit/Tools/qmake/mkspecs/features/features.pri	2015-12-17 16:26:56.000000000 +0100
@@ -55,7 +55,7 @@
     ENABLE_FULLSCREEN_API=1 \
     ENABLE_GAMEPAD=0 \
     ENABLE_GEOLOCATION=1 \
-    ENABLE_GESTURE_EVENTS=1 \
+    ENABLE_GESTURE_EVENTS=0 \
     ENABLE_HIGH_DPI_CANVAS=0 \
     ENABLE_ICONDATABASE=1 \
     ENABLE_IFRAME_SEAMLESS=1 \
@@ -111,8 +111,8 @@
     ENABLE_TEMPLATE_ELEMENT=0 \
     ENABLE_TEXT_AUTOSIZING=0 \
     ENABLE_THREADED_HTML_PARSER=0 \
-    ENABLE_TOUCH_ADJUSTMENT=1 \
-    ENABLE_TOUCH_EVENTS=1 \
+    ENABLE_TOUCH_ADJUSTMENT=0 \
+    ENABLE_TOUCH_EVENTS=0 \
     ENABLE_TOUCH_ICON_LOADING=0 \
     ENABLE_USER_TIMING=0 \
     ENABLE_VIBRATION=0 \
